<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>RummyTable Pro</title>
    
    <!-- PWA / iOS Meta Tags -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="RummyTable">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#1a472a">

    <!-- Web App Manifest (Generated inline) -->
    <script>
        const manifest = {
            "name": "RummyTable Pro",
            "short_name": "RummyTable",
            "display": "standalone",
            "start_url": ".",
            "background_color": "#1a472a",
            "theme_color": "#1a472a",
            "icons": [
                {
                    "src": "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512'%3E%3Crect width='512' height='512' fill='%231a472a'/%3E%3Ctext x='50%25' y='50%25' dominant-baseline='middle' text-anchor='middle' font-family='sans-serif' font-size='256' fill='%23fdf6e3'%3E13%3C/text%3E%3C/svg%3E",
                    "sizes": "192x192",
                    "type": "image/svg+xml"
                }
            ]
        };
        const stringManifest = JSON.stringify(manifest);
        const blob = new Blob([stringManifest], {type: 'application/json'});
        const manifestURL = URL.createObjectURL(blob);
        const link = document.createElement('link');
        link.rel = 'manifest';
        link.href = manifestURL;
        document.head.appendChild(link);
    </script>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              rummy: {
                board: '#1a472a', // Classic felt green
                tile: '#fdf6e3',  // Creamy white
                tileShadow: '#d4c5a3',
                black: '#1a1a1a',
                blue: '#0066cc',
                red: '#cc0000',
                orange: '#e69500',
              }
            },
            boxShadow: {
              'tile': '2px 3px 0px 0px rgba(180, 160, 120, 1), 4px 5px 5px 0px rgba(0,0,0,0.2)',
              'tile-selected': '0px 0px 0px 3px #3b82f6, 4px 5px 5px 0px rgba(0,0,0,0.2)',
              'tile-inverted': '-2px -3px 0px 0px rgba(180, 160, 120, 1), -4px -5px 5px 0px rgba(0,0,0,0.2)',
              'inner-depth': 'inset 2px 2px 4px rgba(0,0,0,0.2)',
            }
          },
        },
      }
    </script>

    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel for JSX/TSX compilation in browser -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
      /* Prevent pull-to-refresh on iPad and handle selection */
      body {
        overscroll-behavior-y: none;
        -webkit-user-select: none;
        user-select: none;
        background-color: #111827; /* gray-900 */
        overflow: hidden;
        touch-action: none;
      }
      #root {
        width: 100%;
        height: 100%;
      }
    </style>
<script type="importmap">
{
  "imports": {
    "react": "https://aistudiocdn.com/react@^19.2.0",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/",
    "react/": "https://aistudiocdn.com/react@^19.2.0/",
    "uuid": "https://aistudiocdn.com/uuid@^13.0.0",
    "clsx": "https://aistudiocdn.com/clsx@^2.1.1",
    "lucide-react": "https://aistudiocdn.com/lucide-react@^0.555.0"
  }
}
</script>
</head>
<body class="bg-gray-900 overflow-hidden touch-none">
    <div id="root"></div>

    <!-- MAIN APPLICATION SCRIPT -->
    <script type="text/babel" data-presets="typescript,react">
        const { useState, useEffect, useCallback, useRef } = React;

        // ----------------------------------------------------------------------
        // 1. UTILITIES & LIBRARIES SHIMS
        // ----------------------------------------------------------------------

        // Simple UUID v4 generator
        const uuidv4 = () => {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        };

        // Classnames helper
        const clsx = (...args) => {
            return args.filter(Boolean).join(' ');
        };

        // Lucide Icons Shim (Inline SVGs)
        const IconBase = ({ size = 24, className, children, ...props }) => (
            <svg 
                xmlns="http://www.w3.org/2000/svg" 
                width={size} 
                height={size} 
                viewBox="0 0 24 24" 
                fill="none" 
                stroke="currentColor" 
                strokeWidth="2" 
                strokeLinecap="round" 
                strokeLinejoin="round" 
                className={className} 
                {...props}
            >
                {children}
            </svg>
        );

        const Ghost = (props) => <IconBase {...props}><path d="M9 10h.01"/><path d="M15 10h.01"/><path d="M12 2a8 8 0 0 0-8 8v12l3-3 2.5 2.5L12 19l2.5 2.5L17 19l3 3V10a8 8 0 0 0-8-8z"/></IconBase>;
        const Palette = (props) => <IconBase {...props}><circle cx="13.5" cy="6.5" r=".5"/><circle cx="17.5" cy="10.5" r=".5"/><circle cx="8.5" cy="7.5" r=".5"/><circle cx="6.5" cy="12.5" r=".5"/><path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10c.926 0 1.648-.746 1.648-1.688 0-.437-.18-.835-.437-1.125-.29-.289-.438-.652-.438-1.125a1.64 1.64 0 0 1 1.668-1.668h1.996c3.051 0 5.555-2.503 5.555-5.554C21.965 6.012 17.461 2 12 2z"/></IconBase>;
        const Layers = (props) => <IconBase {...props}><polygon points="12 2 2 7 12 12 22 7 12 2"/><polyline points="2 17 12 22 22 17"/><polyline points="2 12 12 17 22 12"/></IconBase>;
        const PlusSquare = (props) => <IconBase {...props}><rect width="18" height="18" x="3" y="3" rx="2"/><path d="M8 12h8"/><path d="M12 8v8"/></IconBase>;
        const Download = (props) => <IconBase {...props}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" x2="12" y1="15" y2="3"/></IconBase>;
        const ChevronUp = (props) => <IconBase {...props}><path d="m18 15-6-6-6 6"/></IconBase>;
        const ChevronDown = (props) => <IconBase {...props}><path d="m6 9 6 6 6-6"/></IconBase>;
        const Move = (props) => <IconBase {...props}><polyline points="5 9 2 12 5 15"/><polyline points="9 5 12 2 15 5"/><polyline points="15 19 12 22 9 19"/><polyline points="19 9 22 12 19 15"/><line x1="2" x2="22" y1="12" y2="12"/><line x1="12" x2="12" y1="2" y2="22"/></IconBase>;
        const RotateCcw = (props) => <IconBase {...props}><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></IconBase>;
        const Play = (props) => <IconBase {...props}><polygon points="5 3 19 12 5 21 5 3"/></IconBase>;
        const Trash2 = (props) => <IconBase {...props}><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/><line x1="10" x2="10" y1="11" y2="17"/><line x1="14" x2="14" y1="11" y2="17"/></IconBase>;
        const Repeat = (props) => <IconBase {...props}><path d="m17 2 4 4-4 4"/><path d="M3 11v-1a4 4 0 0 1 4-4h14"/><path d="m7 22-4-4 4-4"/><path d="M21 13v1a4 4 0 0 1-4 4H3"/></IconBase>;
        const History = (props) => <IconBase {...props}><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></IconBase>;
        const Minimize2 = (props) => <IconBase {...props}><polyline points="4 14 10 14 10 20"/><polyline points="20 10 14 10 14 4"/><line x1="14" x2="21" y1="10" y2="3"/><line x1="3" x2="10" y1="21" y2="14"/></IconBase>;
        const AlertTriangle = (props) => <IconBase {...props}><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"/><line x1="12" x2="12" y1="9" y2="13"/><line x1="12" x2="12.01" y1="17" y2="17"/></IconBase>;


        // ----------------------------------------------------------------------
        // 2. CONSTANTS
        // ----------------------------------------------------------------------

        const COLORS = ['BLACK', 'BLUE', 'RED', 'ORANGE'];
        const MIN_VALUE = 1;
        const MAX_VALUE = 13;
        const DUPLICATES_PER_DECK = 2; // Two sets of 1-13 per color
        const JOKER_COUNT = 2;
        const RACK_COLS = 10; // Start with 10 columns
        const RACK_ROWS = 2;  // Start with 2 rows, expand to 3 if needed

        const COLOR_MAP = {
            BLACK: 'text-rummy-black',
            BLUE: 'text-rummy-blue',
            RED: 'text-rummy-red',
            ORANGE: 'text-rummy-orange',
        };

        const HEX_MAP = {
            BLACK: '#1a1a1a',
            BLUE: '#0066cc',
            RED: '#cc0000',
            ORANGE: '#e69500',
        };

        // ----------------------------------------------------------------------
        // 3. GAME LOGIC & UTILS
        // ----------------------------------------------------------------------

        const shuffleDeck = (deck) => {
            const newDeck = [...deck];
            for (let i = newDeck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newDeck[i], newDeck[j]] = [newDeck[j], newDeck[i]];
            }
            return newDeck;
        };

        const generateDeck = () => {
            const deck = [];
            COLORS.forEach(color => {
                for (let i = 0; i < DUPLICATES_PER_DECK; i++) {
                for (let val = MIN_VALUE; val <= MAX_VALUE; val++) {
                    deck.push({
                    id: uuidv4(),
                    value: val,
                    color: color,
                    isJoker: false,
                    });
                }
                }
            });

            // Generate Jokers (One Black, One Red)
            const jokerColors = ['BLACK', 'RED'];
            for (let i = 0; i < JOKER_COUNT; i++) {
                deck.push({
                id: uuidv4(),
                value: 0,
                color: jokerColors[i % jokerColors.length], 
                isJoker: true,
                });
            }

            return shuffleDeck(deck);
        };

        const sortTiles = (tiles, method) => {
            const sorted = [...tiles];
            switch (method) {
                case 'RUN': 
                return sorted.sort((a, b) => {
                    if (a.isJoker) return 1;
                    if (b.isJoker) return -1;
                    if (a.color !== b.color) return (a.color || '').localeCompare(b.color || '');
                    return a.value - b.value;
                });
                case 'GROUP': 
                return sorted.sort((a, b) => {
                    if (a.isJoker) return 1;
                    if (b.isJoker) return -1;
                    if (a.value !== b.value) return a.value - b.value;
                    return (a.color || '').localeCompare(b.color || '');
                });
                default:
                return sorted;
            }
        };

        const separateHand = (tiles) => {
            const unique = [];
            const duplicates = [];
            const seen = new Set();
            tiles.forEach(tile => {
                const key = tile.isJoker ? 'JOKER' : `${tile.color}-${tile.value}`;
                if (seen.has(key)) {
                    duplicates.push(tile);
                } else {
                    seen.add(key);
                    unique.push(tile);
                }
            });
            return [...unique, ...duplicates];
        };

        const sortHand = (tiles, method) => {
            // 1. Sort Logical Order
            const sorted = sortTiles(tiles, method);
            
            // 2. Separate into Unique and Duplicates AND Tag
            const unique = [];
            const duplicates = [];
            const seen = new Set();

            sorted.forEach(tile => {
                const key = tile.isJoker ? 'JOKER' : `${tile.color}-${tile.value}`;
                if (seen.has(key)) {
                    tile.isDuplicate = true;
                    duplicates.push(tile);
                } else {
                    tile.isDuplicate = false;
                    seen.add(key);
                    unique.push(tile);
                }
            });

            // 3. Assign Grid Positions
            const totalTiles = tiles.length;
            const dynamicRows = totalTiles > (RACK_ROWS * RACK_COLS) ? 3 : RACK_ROWS;
            const dynamicCols = Math.max(RACK_COLS, Math.ceil(totalTiles / dynamicRows));

            const positionedTiles = [];

            // Place Unique: Top-Left -> Right -> Down
            let uCol = 0;
            let uRow = 0;
            unique.forEach(tile => {
                positionedTiles.push({ ...tile, rackX: uCol, rackY: uRow });
                uCol++;
                if (uCol >= dynamicCols) {
                    uCol = 0;
                    uRow++;
                }
            });

            // Place Duplicates: Bottom-Right -> Left -> Up
            let dCol = dynamicCols - 1;
            let dRow = dynamicRows - 1;
            duplicates.forEach(tile => {
                positionedTiles.push({ ...tile, rackX: dCol, rackY: dRow });
                dCol--;
                if (dCol < 0) {
                    dCol = dynamicCols - 1;
                    dRow--;
                }
            });

            return positionedTiles;
        };

        const findFreeRackSlot = (tiles) => {
            const totalTiles = tiles.length;
            const maxValX = tiles.reduce((max, t) => Math.max(max, t.rackX || 0), 0);
            
            const dynamicRows = totalTiles > (RACK_ROWS * RACK_COLS) ? 3 : RACK_ROWS;
            const dynamicCols = Math.max(RACK_COLS, Math.ceil(totalTiles / dynamicRows), maxValX + 1);

            const occupied = new Set();
            tiles.forEach(t => {
                if (t.rackX !== undefined && t.rackY !== undefined) {
                    occupied.add(`${t.rackX},${t.rackY}`);
                }
            });

            for (let r = 0; r < dynamicRows; r++) {
                for (let c = 0; c < dynamicCols; c++) {
                    if (!occupied.has(`${c},${r}`)) {
                        return { x: c, y: r };
                    }
                }
            }
            return { x: dynamicCols, y: 0 };
        };

        const organizeRun = (tiles) => {
            const jokers = tiles.filter(t => t.isJoker);
            const nonJokers = tiles.filter(t => !t.isJoker).sort((a, b) => a.value - b.value);
            if (nonJokers.length === 0) return tiles;

            const result = [];
            let currentVal = nonJokers[0].value;
            result.push(nonJokers[0]);

            for (let i = 1; i < nonJokers.length; i++) {
                const nextTile = nonJokers[i];
                const gap = nextTile.value - currentVal - 1;
                for (let k = 0; k < gap; k++) {
                    if (jokers.length > 0) {
                        result.push(jokers.pop());
                        currentVal++;
                    }
                }
                result.push(nextTile);
                currentVal = nextTile.value;
            }

            while (jokers.length > 0) {
                if (currentVal < MAX_VALUE) {
                    result.push(jokers.pop());
                    currentVal++;
                } else {
                    result.unshift(jokers.pop());
                }
            }
            return result;
        };

        const isValidSet = (tiles) => {
            if (tiles.length < 3) return false;
            const jokers = tiles.filter(t => t.isJoker);
            const nonJokers = tiles.filter(t => !t.isJoker);

            const isGroup = () => {
                if (tiles.length > 4) return false;
                if (nonJokers.length === 0) return true;
                const targetValue = nonJokers[0].value;
                const seenColors = new Set();
                for (const tile of nonJokers) {
                    if (tile.value !== targetValue) return false;
                    if (tile.color && seenColors.has(tile.color)) return false;
                    if (tile.color) seenColors.add(tile.color);
                }
                return true;
            };

            const isRun = () => {
                if (tiles.length > 13) return false;
                if (nonJokers.length === 0) return true;
                const targetColor = nonJokers[0].color;
                if (!nonJokers.every(t => t.color === targetColor)) return false;
                const sortedNonJokers = [...nonJokers].sort((a, b) => a.value - b.value);
                let jokersAvailable = jokers.length;
                for (let i = 0; i < sortedNonJokers.length - 1; i++) {
                    const current = sortedNonJokers[i].value;
                    const next = sortedNonJokers[i+1].value;
                    if (current === next) return false;
                    const gap = next - current - 1; 
                    if (gap > 0) {
                        if (jokersAvailable >= gap) jokersAvailable -= gap;
                        else return false;
                    }
                }
                return true;
            };
            return isGroup() || isRun();
        };

        const autoSortSet = (tiles, requireValid = true) => {
            const runSorted = sortTiles(tiles, 'RUN');
            if (isValidSet(runSorted)) return organizeRun(tiles);
            const groupSorted = sortTiles(tiles, 'GROUP');
            if (isValidSet(groupSorted)) return groupSorted;
            if (requireValid) return null;
            
            const colors = tiles.map(t => t.color).filter(c => c !== null);
            const mostCommonColor = colors.sort((a,b) => colors.filter(v => v===a).length - colors.filter(v => v===b).length).pop();
            const sameColorCount = tiles.filter(t => t.color === mostCommonColor).length;
            if (sameColorCount > tiles.length / 2) return runSorted;
            return groupSorted;
        };

        const validateMove = (existingTiles, newTiles) => {
            const combined = [...existingTiles, ...newTiles];
            return autoSortSet(combined);
        };

        const validateBoard = (board) => board.every(set => isValidSet(set.tiles));

        const getSetDimensions = (tileCount) => {
            const tileWidth = 48;
            const gap = 1; 
            const padding = 2; 
            const width = (tileCount * tileWidth) + ((tileCount - 1) * gap) + padding;
            const height = 80; 
            return { width, height };
        };

        const doRectsIntersect = (r1, r2) => {
            return !(r2.x - r2.w/2 > r1.x + r1.w/2 || 
                    r2.x + r2.w/2 < r1.x - r1.w/2 || 
                    r2.y - r2.h/2 > r1.y + r1.h/2 || 
                    r2.y + r2.h/2 < r1.y - r1.h/2);
        };

        const findFreePosition = (existingSets, tileCount) => {
            const { width, height } = getSetDimensions(tileCount);
            const buffer = 2;
            const newRect = { x: 0, y: 0, w: width + buffer, h: height + buffer };
            
            const a = 5; 
            let angle = 0;
            const step = 0.1; 
            let i = 0;

            while (i < 5000) {
                const radius = a * angle;
                newRect.x = i === 0 ? 0 : radius * Math.cos(angle);
                newRect.y = i === 0 ? 0 : radius * Math.sin(angle);

                const hasCollision = existingSets.some(set => {
                    const dim = getSetDimensions(set.tiles.length);
                    return doRectsIntersect(newRect, { 
                        x: set.x, 
                        y: set.y, 
                        w: dim.width + buffer, 
                        h: dim.height + buffer 
                    });
                });

                if (!hasCollision) return { x: newRect.x, y: newRect.y };
                angle += step;
                i++;
            }
            return { x: 0, y: 0 };
        };

        const compactBoardLogic = (sets) => {
            const sortedSets = [...sets].sort((a, b) => {
                const distA = Math.hypot(a.x, a.y);
                const distB = Math.hypot(b.x, b.y);
                return distA - distB;
            });

            const compactedSets = [];
            for (const set of sortedSets) {
                const { width, height } = getSetDimensions(set.tiles.length);
                const buffer = 2;
                const setRect = { x: 0, y: 0, w: width + buffer, h: height + buffer };
                const angle = Math.atan2(set.y, set.x);
                const maxDist = Math.hypot(set.x, set.y);
                let validX = set.x;
                let validY = set.y;
                const rayStep = 5;
                
                for (let r = 0; r <= maxDist; r += rayStep) {
                    setRect.x = r * Math.cos(angle);
                    setRect.y = r * Math.sin(angle);
                    const collision = compactedSets.some(placedSet => {
                        const dim = getSetDimensions(placedSet.tiles.length);
                        return doRectsIntersect(setRect, {
                            x: placedSet.x, 
                            y: placedSet.y,
                            w: dim.width + buffer,
                            h: dim.height + buffer
                        });
                    });
                    if (!collision) {
                        validX = setRect.x;
                        validY = setRect.y;
                        break;
                    }
                }
                compactedSets.push({ ...set, x: validX, y: validY });
            }
            return compactedSets;
        };

        // ----------------------------------------------------------------------
        // 4. COMPONENTS
        // ----------------------------------------------------------------------

        // --- Tile ---
        const Tile = ({ 
            tile, 
            isSelected = false, 
            isDragging = false,
            isNew = false,
            size = 'md' 
        }) => {
            const colorClass = tile.color ? COLOR_MAP[tile.color] : 'text-gray-800';
            const sizeClasses = {
                sm: 'w-8 h-12 text-xl',
                md: 'w-10 h-14 text-3xl md:w-12 md:h-16 md:text-4xl',
                lg: 'w-14 h-20 text-6xl',
            };
            const jokerSizes = { sm: 20, md: 32, lg: 40 };
            const isSixOrNine = !tile.isJoker && (tile.value === 6 || tile.value === 9);

            return (
                <div
                    className={clsx(
                        "relative flex items-center justify-center rounded-md transition-transform duration-150 select-none cursor-pointer overflow-hidden",
                        "bg-rummy-tile shadow-tile",
                        isSelected ? "shadow-tile-selected -translate-y-1" : "",
                        sizeClasses[size],
                        isSelected ? "" : (
                            isNew ? "border-4 border-green-500 box-border" : (
                                tile.isDuplicate ? "border-4 border-gray-400 border-dashed box-border" : "border border-gray-100"
                            )
                        ),
                        isDragging ? "opacity-0" : "opacity-100" 
                    )}
                >
                    <div className={clsx("font-bold tracking-tighter flex items-center justify-center w-full h-full", colorClass)}>
                        {tile.isJoker ? (
                            <Ghost size={jokerSizes[size]} className="mx-auto" />
                        ) : (
                            <div className="flex flex-col items-center justify-center -mt-2">
                                <span>{tile.value}</span>
                                {isSixOrNine && (
                                    <div className="w-full h-[3px] bg-current mt-[0px] opacity-60 rounded-full"></div>
                                )}
                            </div>
                        )}
                    </div>
                    <div className="absolute inset-0 rounded-md shadow-[inset_0_1px_1px_rgba(255,255,255,0.6),inset_0_-1px_1px_rgba(0,0,0,0.1)] pointer-events-none"></div>
                </div>
            );
        };

        // --- PlayerRack ---
        const PlayerRack = ({
            playerId,
            tiles,
            selectedTileIds,
            draggedTileIds,
            onSort,
            onDraw,
            onPlayNewSet,
            onDragStart,
            interactionMode,
            disabled = false,
            newTileId = null
        }) => {
            const isTop = playerId === 'TOP';
            const [windowWidth, setWindowWidth] = useState(window.innerWidth);
            const [offsetY, setOffsetY] = useState(0);

            const TILE_WIDTH = 50; 
            const TILE_HEIGHT = 70; 
            const totalTiles = tiles.length;
            const dynamicRows = totalTiles > (RACK_ROWS * RACK_COLS) ? 3 : RACK_ROWS;
            const maxTileX = tiles.reduce((max, t) => Math.max(max, t.rackX || 0), 0);
            const tileBasedCols = Math.ceil(tiles.length / dynamicRows);
            const dynamicCols = Math.max(RACK_COLS, tileBasedCols, maxTileX + 1);

            const RAW_GRID_WIDTH = dynamicCols * TILE_WIDTH;
            const RAW_GRID_HEIGHT = dynamicRows * TILE_HEIGHT;
            const BUTTON_PANEL_WIDTH = 90;
            const TOTAL_BUTTON_SPACE = (BUTTON_PANEL_WIDTH * 2) + 32;
            const availableWidth = windowWidth - TOTAL_BUTTON_SPACE;
            const scale = Math.min(1, availableWidth / RAW_GRID_WIDTH);
            const renderedWidth = RAW_GRID_WIDTH * scale;
            const renderedHeight = RAW_GRID_HEIGHT * scale;

            useEffect(() => {
                const handleResize = () => setWindowWidth(window.innerWidth);
                window.addEventListener('resize', handleResize);
                return () => window.removeEventListener('resize', handleResize);
            }, []);

            const gridMap = {};
            tiles.forEach(t => {
                const x = t.rackX ?? 0;
                const y = t.rackY ?? 0;
                gridMap[`${x},${y}`] = t;
            });

            const handleMoveVisualUp = (e) => { e.stopPropagation(); setOffsetY(prev => prev + (isTop ? 10 : -10)); };
            const handleMoveVisualDown = (e) => { e.stopPropagation(); setOffsetY(prev => prev + (isTop ? -10 : 10)); };

            return (
                <div 
                    className={clsx(
                        "flex items-center justify-between p-2 bg-gray-800/95 shadow-2xl backdrop-blur-sm z-40 w-full transition-all duration-300 select-none box-border absolute left-0 right-0",
                        isTop ? "top-0 border-b-4 border-gray-700" : "bottom-0 border-t-4 border-gray-700",
                        disabled ? "opacity-40 pointer-events-none grayscale" : "opacity-100"
                    )}
                    data-rack-id={playerId}
                    style={{ 
                        touchAction: 'none',
                        transform: isTop 
                            ? `rotate(180deg) translateY(${offsetY}px)` 
                            : `translateY(${offsetY}px)`
                    }} 
                >
                    <div className="flex flex-col gap-2 flex-shrink-0 z-20 w-[80px]">
                        {!isTop && (
                            <div className="flex gap-1 mb-1 w-full">
                                <button onPointerDown={handleMoveVisualUp} className="flex-1 bg-gray-700 text-gray-300 rounded p-1 flex items-center justify-center shadow-md active:bg-gray-600 active:text-white transition-colors h-10"><ChevronUp size={24} /></button>
                                <button onPointerDown={handleMoveVisualDown} className="flex-1 bg-gray-700 text-gray-300 rounded p-1 flex items-center justify-center shadow-md active:bg-gray-600 active:text-white transition-colors h-10"><ChevronDown size={24} /></button>
                            </div>
                        )}
                        <button onClick={() => onSort('GROUP')} className="flex flex-col items-center justify-center p-2 bg-gray-700 rounded text-white active:bg-gray-600 hover:bg-gray-600 transition-colors h-16 w-full shadow-md"><Layers size={24} /><span className="text-[10px] font-bold mt-1">123</span></button>
                        <button onClick={() => onSort('RUN')} className="flex flex-col items-center justify-center p-2 bg-gray-700 rounded text-white active:bg-gray-600 hover:bg-gray-600 transition-colors h-16 w-full shadow-md"><Palette size={24} /><span className="text-[10px] font-bold mt-1">Colors</span></button>
                    </div>

                    <div className="flex-grow flex justify-center items-center overflow-hidden h-full">
                        <div className="relative overflow-visible" style={{ width: renderedWidth, height: renderedHeight }}>
                            <div className="absolute top-0 left-0 origin-top-left" style={{ width: RAW_GRID_WIDTH, height: RAW_GRID_HEIGHT, transform: `scale(${scale})` }}>
                                {Array.from({ length: dynamicRows }).map((_, r) => (
                                    Array.from({ length: dynamicCols }).map((_, c) => {
                                        const tile = gridMap[`${c},${r}`];
                                        return (
                                            <div key={`${c}-${r}`} data-slot-x={c} data-slot-y={r} className="absolute w-[48px] h-[64px] rounded border-transparent" style={{ left: c * 50, top: r * 70 }}>
                                                {tile && (
                                                    <div
                                                        onPointerDown={(e) => {
                                                            if (interactionMode === 'IDLE' || interactionMode === 'REORDER_BOARD') {
                                                                onDragStart(e, tile, `RACK_${playerId}`);
                                                            }
                                                        }}
                                                        className="touch-none w-full h-full"
                                                    >
                                                        <Tile tile={tile} isSelected={selectedTileIds.includes(tile.id)} isDragging={draggedTileIds.includes(tile.id)} isNew={tile.id === newTileId} size="md" />
                                                    </div>
                                                )}
                                            </div>
                                        );
                                    })
                                ))}
                            </div>
                        </div>
                    </div>

                    <div className="flex flex-col gap-2 flex-shrink-0 z-20 w-[80px]">
                        <button onClick={onDraw} className="flex flex-col items-center justify-center p-2 bg-gray-600 rounded text-white font-bold text-sm active:scale-95 transition-transform h-14 w-full shadow-lg"><Download size={20} className="mb-1" /><span className="text-[10px]">DRAW</span></button>
                        <button onClick={onPlayNewSet} className="flex flex-col items-center justify-center p-2 bg-green-700 rounded text-white font-bold text-sm active:scale-95 transition-transform shadow-lg h-14 w-full"><PlusSquare size={20} className="mb-1" /><span className="text-[10px]">PLAY SET</span></button>
                    </div>
                </div>
            );
        };

        // --- GameBoard ---
        const GameBoard = ({ 
            sets, interactionMode, gamePhase, setupState, draggedTileIds, hasSelectedTiles,
            onSetClick, onToggleReorder, onResetBoard, onResetGame, onDragStart, onSetupDraw,
            onStartGame, onSetDragStart, onSetRotate, onCycleRotate, onCompactBoard
        }) => {
            const isReordering = interactionMode === 'REORDER_BOARD';
            const boardRef = useRef(null);
            const [boardScale, setBoardScale] = useState(1);
            const allSetsValid = sets.every(s => isValidSet(s.tiles));

            useEffect(() => {
                if (sets.length === 0) { setBoardScale(1); return; }
                let maxDistX = 0; let maxDistY = 0;
                sets.forEach(set => {
                    const { width, height } = getSetDimensions(set.tiles.length);
                    const distX = Math.abs(set.x) + width / 2;
                    const distY = Math.abs(set.y) + height / 2;
                    if (distX > maxDistX) maxDistX = distX;
                    if (distY > maxDistY) maxDistY = distY;
                });
                const safeWidth = (window.innerWidth / 2) - 80; 
                const safeHeight = (window.innerHeight / 2) - 120;
                let scaleX = 1; let scaleY = 1;
                if (maxDistX > safeWidth) scaleX = safeWidth / maxDistX;
                if (maxDistY > safeHeight) scaleY = safeHeight / maxDistY;
                setBoardScale(Math.max(0.4, Math.min(1, Math.min(scaleX, scaleY))));
            }, [sets, window.innerWidth, window.innerHeight]);

            if (gamePhase === 'SETUP') {
                return (
                    <div className="flex-1 bg-rummy-board relative flex flex-col items-center justify-center overflow-hidden shadow-inner">
                        <div className="absolute inset-0 opacity-20 pointer-events-none z-0" style={{ backgroundImage: 'radial-gradient(#ffffff 1px, transparent 1px)', backgroundSize: '20px 20px' }}></div>
                        <div className="relative w-64 h-64 flex items-center justify-center">
                            {[...Array(6)].map((_, i) => (
                                <div key={i} className="absolute w-12 h-16 bg-rummy-tile shadow-tile border border-gray-300 rounded" style={{ transform: `rotate(${Math.random() * 360}deg) translate(${Math.random() * 40 - 20}px, ${Math.random() * 40 - 20}px)`, zIndex: 0 }} />
                            ))}
                            {setupState.topCard && setupState.bottomCard && (
                                <button onClick={onStartGame} className="absolute z-50 bg-green-600 text-white font-bold text-xl px-8 py-4 rounded-full shadow-2xl animate-bounce flex items-center gap-2 hover:bg-green-500 transition-colors"><Play fill="currentColor" /> Start Game</button>
                            )}
                        </div>
                        <div className="absolute top-20 rotate-180 flex flex-col items-center gap-4">
                            {setupState.topCard ? (<div className="scale-150"><Tile tile={setupState.topCard} /></div>) : (<button onClick={() => onSetupDraw('TOP')} className="bg-gray-800 text-white px-6 py-3 rounded-lg shadow-xl font-bold active:scale-95 transition-transform">Draw for Start</button>)}
                        </div>
                        <div className="absolute bottom-20 flex flex-col items-center gap-4">
                            {setupState.bottomCard ? (<div className="scale-150"><Tile tile={setupState.bottomCard} /></div>) : (<button onClick={() => onSetupDraw('BOTTOM')} className="bg-gray-800 text-white px-6 py-3 rounded-lg shadow-xl font-bold active:scale-95 transition-transform">Draw for Start</button>)}
                        </div>
                    </div>
                );
            }

            return (
                <div id="game-board-container" ref={boardRef} className="flex-1 bg-rummy-board relative overflow-hidden flex flex-col shadow-inner select-none" style={{ touchAction: isReordering ? 'none' : 'auto' }}>
                    <div className="absolute inset-0 opacity-20 pointer-events-none z-0" style={{ backgroundImage: 'radial-gradient(#ffffff 1px, transparent 1px)', backgroundSize: '20px 20px' }}></div>

                    <div className="absolute top-1/2 left-0 transform -translate-y-1/2 -translate-x-1/2 z-20 -rotate-90 origin-center flex flex-col items-center">
                        <div className="flex gap-4 p-4 bg-gray-900/50 backdrop-blur-md rounded-2xl shadow-2xl border border-white/10">
                            {!isReordering && (
                                <button onClick={(e) => { e.stopPropagation(); onResetGame(); }} className="flex flex-col items-center justify-center gap-1 w-16 h-16 rounded-xl shadow-lg font-bold transition-all bg-gray-800 text-white hover:bg-gray-700 border border-gray-600 active:scale-95" title="Start New Game"><Trash2 size={24} /><span className="text-[10px] leading-none text-center">NEW<br/>GAME</span></button>
                            )}
                        </div>
                    </div>

                    <div className="absolute top-1/2 right-0 transform -translate-y-1/2 translate-x-1/2 z-20 rotate-90 origin-center flex flex-col items-center">
                        <div className="flex gap-4 p-4 bg-gray-900/50 backdrop-blur-md rounded-2xl shadow-2xl border border-white/10">
                            {isReordering && (
                                <button onClick={(e) => { e.stopPropagation(); onResetBoard(); }} className="flex flex-col items-center justify-center gap-1 w-16 h-16 rounded-xl shadow-lg font-bold transition-all bg-yellow-600 text-white hover:bg-yellow-500 active:scale-95"><RotateCcw size={24} /><span className="text-[10px] leading-none">RESET</span></button>
                            )}
                            <button onClick={(e) => { e.stopPropagation(); onToggleReorder(); }} className={clsx("flex flex-col items-center justify-center gap-1 w-16 h-16 rounded-xl shadow-lg font-bold transition-all active:scale-95", isReordering ? (allSetsValid ? "bg-green-600 text-white hover:bg-green-500" : "bg-red-600 text-white hover:bg-red-500 animate-pulse") : "bg-blue-600 text-white hover:bg-blue-500")}><Move size={24} /><span className="text-[10px] leading-none text-center">{isReordering ? "DONE" : "REORDER"}</span></button>
                            <button onClick={(e) => { e.stopPropagation(); onCycleRotate(); }} className="flex flex-col items-center justify-center gap-1 w-16 h-16 rounded-xl shadow-lg font-bold transition-all bg-indigo-600 text-white hover:bg-indigo-500 active:scale-95" title="Rotate Orientation"><Repeat size={24} /><span className="text-[10px] leading-none text-center">ROTATE</span></button>
                            <button onClick={(e) => { e.stopPropagation(); onCompactBoard(); }} className="flex flex-col items-center justify-center gap-1 w-16 h-16 rounded-xl shadow-lg font-bold transition-all bg-yellow-500 text-black hover:bg-yellow-400 active:scale-95" title="Compact Board"><Minimize2 size={24} /><span className="text-[10px] leading-none text-center">COMPACT</span></button>
                        </div>
                    </div>

                    <div id="game-board" className="absolute left-1/2 top-1/2 w-0 h-0 overflow-visible z-10 transition-transform duration-500 ease-out" style={{ transform: `scale(${boardScale})` }}>
                        {sets.map((set) => {
                            const isValid = isValidSet(set.tiles);
                            const baseRotation = set.orientation === 'TOP' ? 180 : 0;
                            const randomRotation = set.rotation || 0;
                            const x = set.x || 0;
                            const y = set.y || 0;
                            
                            return (
                                <div 
                                    key={set.id}
                                    data-set-id={set.id}
                                    onPointerUp={() => onSetClick(set.id)}
                                    onPointerDown={(e) => { if (!isReordering && !hasSelectedTiles) onSetDragStart(e, set.id); }}
                                    style={{ transform: `translate(-50%, -50%) translate(${x}px, ${y}px) rotate(${baseRotation + randomRotation}deg)`, position: 'absolute', left: 0, top: 0 }}
                                    className={clsx("bg-black/10 rounded-xl p-3 flex gap-1 transition-colors duration-200 border-2 items-center min-w-max", isReordering ? (isValid ? "border-white/50 border-dashed" : "border-red-500 bg-red-900/20 border-dashed") : (!hasSelectedTiles ? "border-transparent hover:bg-white/5 cursor-move" : "border-transparent hover:bg-white/5"))}
                                >
                                    {isReordering && (
                                        <>
                                            <div onPointerDown={(e) => onSetDragStart(e, set.id)} className="absolute -top-10 left-1/2 -translate-x-[120%] w-10 h-10 bg-blue-600 rounded-full flex items-center justify-center shadow-lg cursor-move active:scale-95 transition-transform z-30"><Move size={20} className="text-white" /></div>
                                            <div onPointerDown={(e) => { e.stopPropagation(); onSetRotate(set.id); }} className="absolute -top-10 left-1/2 translate-x-[20%] w-10 h-10 bg-yellow-600 rounded-full flex items-center justify-center shadow-lg cursor-pointer active:scale-95 transition-transform z-30"><RotateCcw size={20} className="text-white" /></div>
                                        </>
                                    )}
                                    {set.tiles.map((tile) => (
                                        <div key={tile.id} onPointerDown={(e) => { if (isReordering) onDragStart(e, tile, set.id); }} className={clsx(isReordering ? "cursor-grab active:cursor-grabbing" : "")}>
                                            <Tile tile={tile} size="md" isDragging={draggedTileIds.includes(tile.id)} />
                                        </div>
                                    ))}
                                </div>
                            );
                        })}
                    </div>
                </div>
            );
        };

        // ----------------------------------------------------------------------
        // 5. APP CONTROLLER
        // ----------------------------------------------------------------------

        const DEFAULT_STATE = {
            gamePhase: 'SETUP',
            deck: [],
            board: [],
            boardSnapshot: null,
            rackSnapshots: null,
            playerTopHand: [],
            playerBottomHand: [],
            playerTopSort: 'RUN', 
            playerBottomSort: 'RUN', 
            selectedTileIds: { TOP: [], BOTTOM: [] },
            activePlayer: null,
            interactionMode: 'IDLE',
            activeDrags: {},
            setupState: { topCard: null, bottomCard: null },
            lastDrawnTileId: { TOP: null, BOTTOM: null }
        };

        const App = () => {
            const [gameState, setGameState] = useState(() => {
                const saved = localStorage.getItem('rummikub_state');
                if (saved) {
                    try {
                        const parsed = JSON.parse(saved);
                        if (parsed.board) {
                            parsed.board = parsed.board.map(s => ({ ...s, x: s.x ?? 0, y: s.y ?? 0, createdBy: s.createdBy ?? s.orientation }));
                        }
                        ['playerTopHand', 'playerBottomHand'].forEach(key => {
                            if (parsed[key]) parsed[key] = sortHand(parsed[key], 'RUN'); 
                        });
                        if (Array.isArray(parsed.selectedTileIds)) parsed.selectedTileIds = { TOP: [], BOTTOM: [] };
                        if (parsed.dragState) { parsed.activeDrags = {}; delete parsed.dragState; }
                        return parsed;
                    } catch (e) { console.error("Failed to load state", e); }
                }
                return DEFAULT_STATE;
            });
            const [showNewGameModal, setShowNewGameModal] = useState(false);
            const dragOffsetsRef = useRef({});

            useEffect(() => { localStorage.setItem('rummikub_state', JSON.stringify(gameState)); }, [gameState]);

            useEffect(() => {
                if (gameState.deck.length === 0 && gameState.gamePhase === 'SETUP' && !gameState.setupState.topCard) {
                    setGameState(prev => ({ ...prev, deck: generateDeck() }));
                }
            }, []);

            const getRandomRotation = () => (Math.random() * 4) - 2;

            const handleResetGame = () => setShowNewGameModal(true);
            const confirmNewGameReset = () => {
                localStorage.removeItem('rummikub_state');
                const newDeck = generateDeck();
                setGameState({ ...DEFAULT_STATE, deck: newDeck, gamePhase: 'SETUP', setupState: { topCard: null, bottomCard: null } });
                setShowNewGameModal(false);
            };

            const handleSetupDraw = (pid) => {
                setGameState(prev => {
                    if (prev.gamePhase !== 'SETUP') return prev;
                    if (pid === 'TOP' && prev.setupState.topCard) return prev;
                    if (pid === 'BOTTOM' && prev.setupState.bottomCard) return prev;
                    const newDeck = [...prev.deck];
                    const randomIndex = Math.floor(Math.random() * newDeck.length);
                    const drawnTile = newDeck.splice(randomIndex, 1)[0];
                    return { ...prev, deck: newDeck, setupState: { ...prev.setupState, topCard: pid === 'TOP' ? drawnTile : prev.setupState.topCard, bottomCard: pid === 'BOTTOM' ? drawnTile : prev.setupState.bottomCard } };
                });
            };

            const handleStartGame = () => {
                const fullDeck = generateDeck();
                const hand1 = fullDeck.splice(0, 14);
                const hand2 = fullDeck.splice(0, 14);
                setGameState(prev => ({ ...prev, gamePhase: 'PLAYING', deck: fullDeck, playerTopHand: sortHand(hand1, prev.playerTopSort), playerBottomHand: sortHand(hand2, prev.playerBottomSort), setupState: { topCard: null, bottomCard: null }, lastDrawnTileId: { TOP: null, BOTTOM: null } }));
            };

            const handleDragStart = (e, tile, sourceSetId) => {
                e.preventDefault(); e.stopPropagation();
                if (Object.values(gameState.activeDrags).some(d => d.tileId === tile.id)) return;
                const rect = e.currentTarget.getBoundingClientRect();
                dragOffsetsRef.current[e.pointerId] = { x: e.clientX - rect.left, y: e.clientY - rect.top };
                setGameState(prev => ({ ...prev, activeDrags: { ...prev.activeDrags, [e.pointerId]: { isDragging: false, tileId: tile.id, sourceSetId, x: e.clientX, y: e.clientY, startX: e.clientX, startY: e.clientY, tileData: tile, draggingSetId: null, initialSetPos: null } } }));
            };

            const handleSetDragStart = (e, setId) => {
                e.preventDefault(); e.stopPropagation();
                if (Object.values(gameState.activeDrags).some(d => d.draggingSetId === setId)) return;
                const set = gameState.board.find(s => s.id === setId);
                if (!set) return;
                dragOffsetsRef.current[e.pointerId] = { x: 0, y: 0 };
                setGameState(prev => ({ ...prev, activeDrags: { ...prev.activeDrags, [e.pointerId]: { isDragging: true, draggingSetId: setId, tileId: null, initialSetPos: { x: set.x, y: set.y }, startX: e.clientX, startY: e.clientY, x: e.clientX, y: e.clientY, sourceSetId: null, tileData: null } } }));
            };

            const handleSetRotate = (setId) => { setGameState(prev => ({ ...prev, board: prev.board.map(s => s.id === setId ? { ...s, orientation: s.orientation === 'TOP' ? 'BOTTOM' : 'TOP' } : s) })); };
            const handleCycleRotate = () => { setGameState(prev => { const topCount = prev.board.filter(s => s.orientation === 'TOP').length; const target = topCount > prev.board.length / 2 ? 'BOTTOM' : 'TOP'; return { ...prev, board: prev.board.map(s => ({ ...s, orientation: target })) }; }); };
            const handleCompactBoard = () => { setGameState(prev => ({ ...prev, board: compactBoardLogic(prev.board) })); };

            const handlePointerMove = (e) => {
                e.preventDefault();
                const dragData = gameState.activeDrags[e.pointerId];
                if (!dragData) return;
                const { tileId, isDragging, startX, startY, draggingSetId, initialSetPos } = dragData;
                if (isDragging && draggingSetId && initialSetPos) {
                    const dx = e.clientX - startX;
                    const dy = e.clientY - startY;
                    setGameState(prev => ({ ...prev, board: prev.board.map(s => s.id === draggingSetId ? { ...s, x: initialSetPos.x + dx, y: initialSetPos.y + dy } : s), activeDrags: { ...prev.activeDrags, [e.pointerId]: { ...dragData, x: e.clientX, y: e.clientY } } }));
                    return;
                }
                if (tileId) {
                    if (!isDragging) {
                        const dist = Math.hypot(e.clientX - startX, e.clientY - startY);
                        if (dist > 5) setGameState(prev => ({ ...prev, activeDrags: { ...prev.activeDrags, [e.pointerId]: { ...dragData, isDragging: true, x: e.clientX, y: e.clientY } } }));
                    } else {
                        setGameState(prev => ({ ...prev, activeDrags: { ...prev.activeDrags, [e.pointerId]: { ...dragData, x: e.clientX, y: e.clientY } } }));
                    }
                }
            };

            const handlePointerUp = (e) => {
                const dragData = gameState.activeDrags[e.pointerId];
                if (!dragData) return;
                delete dragOffsetsRef.current[e.pointerId];
                const { isDragging, tileId, tileData, sourceSetId, draggingSetId } = dragData;
                const cleanupDrag = (state) => { const newDrags = { ...state.activeDrags }; delete newDrags[e.pointerId]; return { ...state, activeDrags: newDrags }; };

                if (draggingSetId) { setGameState(prev => cleanupDrag(prev)); return; }
                if (!tileId || !tileData) { setGameState(prev => cleanupDrag(prev)); return; }

                if (!isDragging) {
                    const owner = sourceSetId?.includes('TOP') ? 'TOP' : (sourceSetId?.includes('BOTTOM') ? 'BOTTOM' : null);
                    if (owner) handleTileClick(tileId, owner);
                    setGameState(prev => cleanupDrag(prev));
                    return;
                }

                const elements = document.elementsFromPoint(e.clientX, e.clientY);
                const targetRackElement = elements.find(el => el.hasAttribute('data-rack-id'));
                const targetRackId = targetRackElement?.getAttribute('data-rack-id');
                const targetSlotElement = elements.find(el => el.hasAttribute('data-slot-x'));
                const targetSetElement = elements.find(el => el.hasAttribute('data-set-id'));
                const targetSetId = targetSetElement?.getAttribute('data-set-id');

                setGameState(prev => {
                    if (targetRackId) {
                        const isTop = targetRackId === 'TOP';
                        const currentHand = isTop ? [...prev.playerTopHand] : [...prev.playerBottomHand];
                        let updatedHand = currentHand.filter(t => t.id !== tileId);
                        let newX = 0, newY = 0;
                        if (targetSlotElement) {
                            newX = parseInt(targetSlotElement.getAttribute('data-slot-x') || '0');
                            newY = parseInt(targetSlotElement.getAttribute('data-slot-y') || '0');
                        } else {
                            const pos = findFreeRackSlot(updatedHand);
                            newX = pos.x; newY = pos.y;
                        }
                        const existingOccupantIndex = updatedHand.findIndex(t => t.rackX === newX && t.rackY === newY);
                        const tileToPlace = { ...tileData, rackX: newX, rackY: newY };
                        if (existingOccupantIndex !== -1) {
                            const occupant = updatedHand[existingOccupantIndex];
                            updatedHand.splice(existingOccupantIndex, 1);
                            const occupiedSet = new Set([`${newX},${newY}`]);
                            updatedHand.forEach(t => occupiedSet.add(`${t.rackX},${t.rackY}`));
                            let freeX = 0, freeY = 0;
                            const dynCols = Math.max(10, Math.ceil(updatedHand.length / (updatedHand.length > 20 ? 3 : 2)));
                            outerLoop: for(let r=0; r<3; r++) { 
                                for(let c=0; c<dynCols+2; c++) {
                                    if (!occupiedSet.has(`${c},${r}`)) { freeX = c; freeY = r; break outerLoop; }
                                }
                            }
                            occupant.rackX = freeX; occupant.rackY = freeY;
                            updatedHand.push(occupant); updatedHand.push(tileToPlace);
                        } else { updatedHand.push(tileToPlace); }

                        let newBoard = [...prev.board];
                        if (sourceSetId && sourceSetId.indexOf('RACK') === -1) {
                            const setIndex = newBoard.findIndex(s => s.id === sourceSetId);
                            if (setIndex !== -1) {
                                const setTiles = newBoard[setIndex].tiles.filter(t => t.id !== tileId);
                                if (setTiles.length === 0) newBoard.splice(setIndex, 1);
                                else newBoard[setIndex] = { ...newBoard[setIndex], tiles: setTiles };
                            }
                        }
                        return cleanupDrag({ ...prev, board: newBoard, playerTopHand: isTop ? updatedHand : prev.playerTopHand, playerBottomHand: !isTop ? updatedHand : prev.playerBottomHand, lastDrawnTileId: { ...prev.lastDrawnTileId, [isTop ? 'TOP' : 'BOTTOM']: null } });
                    }

                    if (prev.interactionMode === 'REORDER_BOARD') {
                        let newBoard = [...prev.board];
                        let newTopHand = [...prev.playerTopHand];
                        let newBottomHand = [...prev.playerBottomHand];
                        let sourceWasRack = false;
                        if (sourceSetId && sourceSetId.startsWith('RACK_')) {
                            sourceWasRack = true;
                            if (sourceSetId === 'RACK_TOP') newTopHand = newTopHand.filter(t => t.id !== tileId);
                            else newBottomHand = newBottomHand.filter(t => t.id !== tileId);
                        } else {
                            const sourceSetIndex = newBoard.findIndex(s => s.id === sourceSetId);
                            if (sourceSetIndex !== -1) {
                                let sourceTiles = [...newBoard[sourceSetIndex].tiles];
                                sourceTiles = sourceTiles.filter(t => t.id !== tileId);
                                if (sourceTiles.length === 0) newBoard.splice(sourceSetIndex, 1);
                                else newBoard[sourceSetIndex] = { ...newBoard[sourceSetIndex], tiles: sourceTiles };
                            }
                        }
                        if (targetSetId) {
                            const targetIndex = newBoard.findIndex(s => s.id === targetSetId);
                            if (targetIndex !== -1) {
                                let targetTiles = [...newBoard[targetIndex].tiles, tileData];
                                const sorted = autoSortSet(targetTiles, false); 
                                newBoard[targetIndex] = { ...newBoard[targetIndex], tiles: sorted || targetTiles };
                            }
                        } else {
                            const boardEl = document.getElementById('game-board-container');
                            let dropX = 0, dropY = 0;
                            if (boardEl) {
                                const rect = boardEl.getBoundingClientRect();
                                const centerX = rect.left + rect.width / 2;
                                const centerY = rect.top + rect.height / 2;
                                dropX = e.clientX - centerX;
                                dropY = e.clientY - centerY;
                            }
                            let orientation = 'BOTTOM';
                            if (sourceWasRack) orientation = sourceSetId === 'RACK_TOP' ? 'TOP' : 'BOTTOM';
                            newBoard.push({ id: uuidv4(), tiles: [tileData], orientation: orientation, createdBy: orientation, rotation: getRandomRotation(), x: dropX, y: dropY });
                        }
                        return cleanupDrag({ ...prev, board: newBoard, playerTopHand: newTopHand, playerBottomHand: newBottomHand });
                    }
                    return cleanupDrag(prev);
                });
            };

            const getActiveHand = useCallback((pid) => pid === 'TOP' ? gameState.playerTopHand : gameState.playerBottomHand, [gameState.playerTopHand, gameState.playerBottomHand]);

            const handleTileClick = (tileId, owner) => {
                setGameState(prev => {
                    const currentSelection = prev.selectedTileIds[owner];
                    const isSelected = currentSelection.includes(tileId);
                    const newSelection = isSelected ? currentSelection.filter(id => id !== tileId) : [...currentSelection, tileId];
                    return { ...prev, activePlayer: owner, selectedTileIds: { ...prev.selectedTileIds, [owner]: newSelection } };
                });
            };

            const handleSort = (pid, method) => {
                const hand = getActiveHand(pid);
                const sorted = sortHand(hand, method);
                setGameState(prev => ({ ...prev, playerTopHand: pid === 'TOP' ? sorted : prev.playerTopHand, playerBottomHand: pid === 'BOTTOM' ? sorted : prev.playerBottomHand, playerTopSort: pid === 'TOP' ? method : prev.playerTopSort, playerBottomSort: pid === 'BOTTOM' ? method : prev.playerBottomSort, lastDrawnTileId: { ...prev.lastDrawnTileId, [pid]: null } }));
            };

            const handleDraw = (pid) => {
                setGameState(prev => {
                    if (prev.deck.length === 0) return prev;
                    const newDeck = [...prev.deck];
                    const drawnTile = newDeck.pop();
                    const hand = pid === 'TOP' ? prev.playerTopHand : prev.playerBottomHand;
                    const pos = findFreeRackSlot(hand);
                    drawnTile.rackX = pos.x; drawnTile.rackY = pos.y;
                    const newHand = [...hand, drawnTile];
                    return { ...prev, deck: newDeck, playerTopHand: pid === 'TOP' ? newHand : prev.playerTopHand, playerBottomHand: pid === 'BOTTOM' ? newHand : prev.playerBottomHand, activePlayer: pid, lastDrawnTileId: { ...prev.lastDrawnTileId, [pid]: drawnTile.id } };
                });
            };

            const handlePlayNewSet = (pid) => {
                const hand = getActiveHand(pid);
                const selection = gameState.selectedTileIds[pid];
                const selectedTiles = hand.filter(t => selection.includes(t.id));
                if (selectedTiles.length === 0) return;
                const isReordering = gameState.interactionMode === 'REORDER_BOARD';
                const candidateSet = autoSortSet(selectedTiles, !isReordering);
                if (candidateSet) {
                    const newHand = hand.filter(t => !selection.includes(t.id));
                    const pos = findFreePosition(gameState.board, candidateSet.length);
                    setGameState(prev => ({ ...prev, board: [...prev.board, { id: uuidv4(), tiles: candidateSet, orientation: pid, createdBy: pid, rotation: getRandomRotation(), x: pos.x, y: pos.y }], selectedTileIds: { ...prev.selectedTileIds, [pid]: [] }, playerTopHand: pid === 'TOP' ? newHand : prev.playerTopHand, playerBottomHand: pid === 'BOTTOM' ? newHand : prev.playerBottomHand, activePlayer: pid, lastDrawnTileId: { ...prev.lastDrawnTileId, [pid]: null } }));
                }
            };

            const handleSetClick = (setId) => {
                const pidTop = 'TOP', pidBottom = 'BOTTOM';
                const topSel = gameState.selectedTileIds[pidTop];
                const bottomSel = gameState.selectedTileIds[pidBottom];
                let actingPlayer = null;
                if (topSel.length > 0 && bottomSel.length === 0) actingPlayer = pidTop;
                else if (bottomSel.length > 0 && topSel.length === 0) actingPlayer = pidBottom;
                else if (topSel.length > 0 && bottomSel.length > 0) actingPlayer = gameState.activePlayer || pidBottom;

                if (!actingPlayer) return;
                const targetSetIndex = gameState.board.findIndex(b => b.id === setId);
                if (targetSetIndex === -1) return;
                const targetSet = gameState.board[targetSetIndex];
                const hand = getActiveHand(actingPlayer);
                const selection = gameState.selectedTileIds[actingPlayer];
                const selectedTiles = hand.filter(t => selection.includes(t.id));
                if (selectedTiles.length === 0) return;
                const isReordering = gameState.interactionMode === 'REORDER_BOARD';
                let newTiles = isReordering ? autoSortSet([...targetSet.tiles, ...selectedTiles], false) : validateMove(targetSet.tiles, selectedTiles);
                if (newTiles) {
                    const newHand = hand.filter(t => !selection.includes(t.id));
                    const newBoard = [...gameState.board];
                    newBoard[targetSetIndex] = { ...targetSet, tiles: newTiles };
                    setGameState(prev => ({ ...prev, board: newBoard, playerTopHand: actingPlayer === 'TOP' ? newHand : prev.playerTopHand, playerBottomHand: actingPlayer === 'BOTTOM' ? newHand : prev.playerBottomHand, selectedTileIds: { ...prev.selectedTileIds, [actingPlayer]: [] }, lastDrawnTileId: { ...prev.lastDrawnTileId, [actingPlayer]: null } }));
                }
            };

            const toggleReorder = () => {
                setGameState(prev => {
                    if (prev.interactionMode === 'REORDER_BOARD') {
                        if (!validateBoard(prev.board)) return prev; 
                        return { ...prev, interactionMode: 'IDLE', boardSnapshot: null, rackSnapshots: null, activePlayer: null };
                    } else {
                        return { ...prev, interactionMode: 'REORDER_BOARD', boardSnapshot: JSON.parse(JSON.stringify(prev.board)), rackSnapshots: { TOP: JSON.parse(JSON.stringify(prev.playerTopHand)), BOTTOM: JSON.parse(JSON.stringify(prev.playerBottomHand)) }, activePlayer: null };
                    }
                });
            };

            const handleResetBoard = () => {
                setGameState(prev => ({ ...prev, board: prev.boardSnapshot ? JSON.parse(JSON.stringify(prev.boardSnapshot)) : prev.board, playerTopHand: prev.rackSnapshots ? JSON.parse(JSON.stringify(prev.rackSnapshots.TOP)) : prev.playerTopHand, playerBottomHand: prev.rackSnapshots ? JSON.parse(JSON.stringify(prev.rackSnapshots.BOTTOM)) : prev.playerBottomHand }));
            };

            const draggingTileIds = Object.values(gameState.activeDrags).map(d => d.tileId).filter(id => id !== null);

            return (
                <div 
                    className="flex flex-col h-screen w-screen overflow-hidden bg-gray-900 font-sans touch-none"
                    onPointerMove={handlePointerMove}
                    onPointerUp={handlePointerUp}
                    onPointerCancel={handlePointerUp}
                    onContextMenu={(e) => e.preventDefault()} 
                >
                    {gameState.gamePhase === 'PLAYING' && (
                        <PlayerRack playerId="TOP" tiles={gameState.playerTopHand} selectedTileIds={gameState.selectedTileIds.TOP} draggedTileIds={draggingTileIds} isMyTurn={gameState.activePlayer === 'TOP'} onSort={(method) => handleSort('TOP', method)} onDraw={() => handleDraw('TOP')} onPlayNewSet={() => handlePlayNewSet('TOP')} onDragStart={handleDragStart} interactionMode={gameState.interactionMode} disabled={false} newTileId={gameState.lastDrawnTileId.TOP} />
                    )}
                    <GameBoard sets={gameState.board} interactionMode={gameState.interactionMode} gamePhase={gameState.gamePhase} setupState={gameState.setupState} draggedTileIds={draggingTileIds} hasSelectedTiles={gameState.selectedTileIds.TOP.length > 0 || gameState.selectedTileIds.BOTTOM.length > 0} onSetClick={handleSetClick} onToggleReorder={toggleReorder} onResetBoard={handleResetBoard} onResetGame={handleResetGame} onDragStart={handleDragStart} onSetupDraw={handleSetupDraw} onStartGame={handleStartGame} onSetDragStart={handleSetDragStart} onSetRotate={handleSetRotate} onCycleRotate={handleCycleRotate} onCompactBoard={handleCompactBoard} />
                    {gameState.gamePhase === 'PLAYING' && (
                        <PlayerRack playerId="BOTTOM" tiles={gameState.playerBottomHand} selectedTileIds={gameState.selectedTileIds.BOTTOM} draggedTileIds={draggingTileIds} isMyTurn={gameState.activePlayer === 'BOTTOM'} onSort={(method) => handleSort('BOTTOM', method)} onDraw={() => handleDraw('BOTTOM')} onPlayNewSet={() => handlePlayNewSet('BOTTOM')} onDragStart={handleDragStart} interactionMode={gameState.interactionMode} disabled={false} newTileId={gameState.lastDrawnTileId.BOTTOM} />
                    )}
                    {Object.entries(gameState.activeDrags).map(([pointerId, drag]) => {
                        if (!drag.isDragging || !drag.tileData) return null;
                        const offset = dragOffsetsRef.current[parseInt(pointerId)] || { x: 0, y: 0 };
                        return (
                            <div key={pointerId} className="fixed pointer-events-none z-50 shadow-2xl opacity-90 scale-110" style={{ left: drag.x - offset.x, top: drag.y - offset.y }}>
                                <Tile tile={drag.tileData} size="md" />
                            </div>
                        );
                    })}
                    {showNewGameModal && (
                        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-sm p-4">
                            <div className="bg-gray-800 border border-gray-600 p-8 rounded-2xl shadow-2xl max-w-sm w-full flex flex-col gap-6 animate-in fade-in zoom-in duration-200">
                                <div className="flex flex-col items-center gap-2">
                                    <AlertTriangle size={48} className="text-yellow-500 mb-2" />
                                    <h2 className="text-2xl font-bold text-white text-center">Start New Game?</h2>
                                    <p className="text-gray-300 text-center text-lg leading-relaxed">Are you sure? This will erase the current game and return to the setup phase.</p>
                                </div>
                                <div className="flex gap-4">
                                    <button onClick={() => setShowNewGameModal(false)} className="flex-1 py-4 rounded-xl bg-gray-700 text-white font-bold text-lg active:scale-95 transition-transform hover:bg-gray-600">Cancel</button>
                                    <button onClick={confirmNewGameReset} className="flex-1 py-4 rounded-xl bg-red-600 text-white font-bold text-lg shadow-lg active:scale-95 transition-transform hover:bg-red-500">New Game</button>
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
