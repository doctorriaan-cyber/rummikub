<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
    <title>RummyTable Pro</title>
    
    <!-- PWA Settings -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="RummyTable">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#111827">

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              rummy: {
                board: '#1a472a', // Classic felt green
                tile: '#fdf6e3',  // Creamy white
                tileShadow: '#d4c5a3',
                black: '#1a1a1a',
                blue: '#0066cc',
                red: '#cc0000',
                orange: '#e69500',
              }
            },
            boxShadow: {
              'tile': '2px 3px 0px 0px rgba(180, 160, 120, 1), 4px 5px 5px 0px rgba(0,0,0,0.2)',
              'tile-selected': '0px 0px 0px 3px #3b82f6, 4px 5px 5px 0px rgba(0,0,0,0.2)',
              'tile-inverted': '-2px -3px 0px 0px rgba(180, 160, 120, 1), -4px -5px 5px 0px rgba(0,0,0,0.2)',
              'inner-depth': 'inset 2px 2px 4px rgba(0,0,0,0.2)',
            }
          },
        },
      }
    </script>
    
    <style>
      /* Prevent pull-to-refresh on iPad */
      body {
        overscroll-behavior-y: none;
        -webkit-user-select: none;
        user-select: none;
        /* Safe area handling for notched devices */
        padding-bottom: env(safe-area-inset-bottom);
      }
      
      /* Hide scrollbar */
      ::-webkit-scrollbar {
        display: none;
      }
    </style>

    <!-- Dynamic Manifest -->
    <script>
      const manifest = {
        name: "RummyTable Pro",
        short_name: "RummyTable",
        description: "A 2-player localized Rummikub adaptation optimized for iPad Pro.",
        start_url: ".",
        display: "standalone",
        background_color: "#111827",
        theme_color: "#111827",
        icons: [
          {
            src: "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512'%3E%3Crect width='512' height='512' fill='%231a472a'/%3E%3Crect x='100' y='100' width='312' height='312' rx='40' fill='%23fdf6e3'/%3E%3Ctext x='50%25' y='50%25' dominant-baseline='middle' text-anchor='middle' font-size='200' font-family='sans-serif' fill='%23cc0000' font-weight='bold'%3E13%3C/text%3E%3C/svg%3E",
            sizes: "512x512",
            type: "image/svg+xml"
          }
        ]
      };
      const stringManifest = JSON.stringify(manifest);
      const blob = new Blob([stringManifest], {type: 'application/json'});
      const manifestURL = URL.createObjectURL(blob);
      const link = document.createElement('link');
      link.rel = 'manifest';
      link.href = manifestURL;
      document.head.appendChild(link);
      
      // Also add apple touch icon dynamically
      const iconLink = document.createElement('link');
      iconLink.rel = 'apple-touch-icon';
      iconLink.href = manifest.icons[0].src;
      document.head.appendChild(iconLink);
    </script>

    <!-- Import Map -->
    <script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@18.2.0",
    "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
    "lucide-react": "https://esm.sh/lucide-react@0.292.0",
    "clsx": "https://esm.sh/clsx@2.1.0",
    "uuid": "https://esm.sh/uuid@9.0.1",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/",
    "react/": "https://aistudiocdn.com/react@^19.2.0/"
  }
}
</script>

    <!-- Babel Standalone for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  </head>
  <body class="bg-gray-900 overflow-hidden touch-none h-screen w-screen fixed inset-0">
    <div id="root" class="h-full w-full"></div>

    <script type="text/babel" data-type="module">
      import React, { useState, useEffect, useCallback, useRef } from 'react';
      import { createRoot } from 'react-dom/client';
      import { v4 as uuidv4 } from 'uuid';
      import clsx from 'clsx';
      import { 
        Ghost, 
        Layers, 
        Palette, 
        PlusSquare, 
        Download, 
        ChevronUp, 
        ChevronDown, 
        Move, 
        RotateCcw, 
        Play,
        AlertTriangle
      } from 'lucide-react';

      // --- CONSTANTS ---
      const COLORS = ['BLACK', 'BLUE', 'RED', 'ORANGE'];
      const MIN_VALUE = 1;
      const MAX_VALUE = 13;
      const DUPLICATES_PER_DECK = 2; // Two sets of 1-13 per color
      const JOKER_COUNT = 2;
      const RACK_COLS = 10; // Start with 10 columns
      const RACK_ROWS = 2;  // Start with 2 rows, expand to 3 if needed

      const COLOR_MAP = {
        BLACK: 'text-rummy-black',
        BLUE: 'text-rummy-blue',
        RED: 'text-rummy-red',
        ORANGE: 'text-rummy-orange',
      };

      // --- GAME LOGIC UTILS ---

      const generateDeck = () => {
        const deck = [];

        // Generate Number Tiles
        COLORS.forEach(color => {
          for (let i = 0; i < DUPLICATES_PER_DECK; i++) {
            for (let val = MIN_VALUE; val <= MAX_VALUE; val++) {
              deck.push({
                id: uuidv4(),
                value: val,
                color: color,
                isJoker: false,
              });
            }
          }
        });

        // Generate Jokers (One Black, One Red)
        const jokerColors = ['BLACK', 'RED'];
        for (let i = 0; i < JOKER_COUNT; i++) {
          deck.push({
            id: uuidv4(),
            value: 0,
            // Cycle through Black/Red based on index
            color: jokerColors[i % jokerColors.length], 
            isJoker: true,
          });
        }

        return shuffleDeck(deck);
      };

      const shuffleDeck = (deck) => {
        const newDeck = [...deck];
        for (let i = newDeck.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [newDeck[i], newDeck[j]] = [newDeck[j], newDeck[i]];
        }
        return newDeck;
      };

      const sortTiles = (tiles, method) => {
        const sorted = [...tiles];

        switch (method) {
          case 'RUN': // Sort by Color, then Value (creates runs of colors)
            return sorted.sort((a, b) => {
               if (a.isJoker) return 1;
               if (b.isJoker) return -1;
               if (a.color !== b.color) return (a.color || '').localeCompare(b.color || '');
               return a.value - b.value;
            });

          case 'GROUP': // Sort by Value, then Color (creates groups of numbers)
            return sorted.sort((a, b) => {
              if (a.isJoker) return 1;
              if (b.isJoker) return -1;
              if (a.value !== b.value) return a.value - b.value;
              return (a.color || '').localeCompare(b.color || '');
            });
            
          default:
            return sorted;
        }
      };

      const sortHand = (tiles, method) => {
          // 1. Sort Logical Order
          const sorted = sortTiles(tiles, method);
          
          // 2. Separate into Unique and Duplicates AND Tag
          const unique = [];
          const duplicates = [];
          const seen = new Set();

          sorted.forEach(tile => {
              const key = tile.isJoker ? 'JOKER' : `${tile.color}-${tile.value}`;
              if (seen.has(key)) {
                  tile.isDuplicate = true;
                  duplicates.push(tile);
              } else {
                  tile.isDuplicate = false;
                  seen.add(key);
                  unique.push(tile);
              }
          });

          // 3. Assign Grid Positions
          const totalTiles = tiles.length;
          // Determine rows needed. If > 20 tiles, we need 3 rows. Else 2 rows (default).
          const dynamicRows = totalTiles > (RACK_ROWS * RACK_COLS) ? 3 : RACK_ROWS;
          
          // Determine columns needed. If > 30 (which is 3x10), we expand columns.
          const dynamicCols = Math.max(RACK_COLS, Math.ceil(totalTiles / dynamicRows));

          const positionedTiles = [];

          // Place Unique: Top-Left -> Right -> Down
          let uCol = 0;
          let uRow = 0;
          unique.forEach(tile => {
              positionedTiles.push({ ...tile, rackX: uCol, rackY: uRow });
              uCol++;
              if (uCol >= dynamicCols) {
                  uCol = 0;
                  uRow++;
              }
          });

          // Place Duplicates: Bottom-Right -> Left -> Up
          let dCol = dynamicCols - 1;
          let dRow = dynamicRows - 1;
          duplicates.forEach(tile => {
              positionedTiles.push({ ...tile, rackX: dCol, rackY: dRow });
              dCol--;
              if (dCol < 0) {
                   dCol = dynamicCols - 1;
                   dRow--;
              }
          });

          return positionedTiles;
      };

      const findFreeRackSlot = (tiles) => {
          // Determine dynamic dimensions of current hand
          const totalTiles = tiles.length;
          const maxValX = tiles.reduce((max, t) => Math.max(max, t.rackX || 0), 0);
          
          const dynamicRows = totalTiles > (RACK_ROWS * RACK_COLS) ? 3 : RACK_ROWS;
          const dynamicCols = Math.max(RACK_COLS, Math.ceil(totalTiles / dynamicRows), maxValX + 1);

          // Scan slots from (0,0) across then down
          const occupied = new Set();
          tiles.forEach(t => {
              if (t.rackX !== undefined && t.rackY !== undefined) {
                  occupied.add(`${t.rackX},${t.rackY}`);
              }
          });

          for (let r = 0; r < dynamicRows; r++) {
              for (let c = 0; c < dynamicCols; c++) {
                  if (!occupied.has(`${c},${r}`)) {
                      return { x: c, y: r };
                  }
              }
          }
          
          // If fully full, add to next available column in row 0
          return { x: dynamicCols, y: 0 };
      };

      // Places Jokers into the gaps of a run
      const organizeRun = (tiles) => {
          const jokers = tiles.filter(t => t.isJoker);
          const nonJokers = tiles.filter(t => !t.isJoker).sort((a, b) => a.value - b.value);

          // If only jokers, return as is
          if (nonJokers.length === 0) return tiles;

          const result = [];
          let currentVal = nonJokers[0].value;
          result.push(nonJokers[0]);

          // Fill internal gaps
          for (let i = 1; i < nonJokers.length; i++) {
              const nextTile = nonJokers[i];
              const gap = nextTile.value - currentVal - 1;
              
              for (let k = 0; k < gap; k++) {
                  if (jokers.length > 0) {
                      result.push(jokers.pop());
                      currentVal++;
                  }
              }
              
              result.push(nextTile);
              currentVal = nextTile.value;
          }

          // Distribute remaining jokers (Start or End)
          while (jokers.length > 0) {
              if (currentVal < MAX_VALUE) {
                  // Append to end if not exceeding 13
                  result.push(jokers.pop());
                  currentVal++;
              } else {
                  // Prepend to start
                  result.unshift(jokers.pop());
              }
          }
          
          return result;
      };

      const isValidSet = (tiles) => {
        if (tiles.length < 3) return false;

        const jokers = tiles.filter(t => t.isJoker);
        const nonJokers = tiles.filter(t => !t.isJoker);

        // 1. Check Group (Same Value, Different Colors)
        const isGroup = () => {
          if (tiles.length > 4) return false; // Max 4 colors
          if (nonJokers.length === 0) return true; // All jokers is valid

          const targetValue = nonJokers[0].value;
          const seenColors = new Set();
          
          for (const tile of nonJokers) {
            if (tile.value !== targetValue) return false;
            if (tile.color && seenColors.has(tile.color)) return false; // Duplicate color in group
            if (tile.color) seenColors.add(tile.color);
          }
          return true;
        };

        // 2. Check Run (Same Color, Consecutive Values)
        const isRun = () => {
           if (tiles.length > 13) return false;
           if (nonJokers.length === 0) return true;

           // Ensure all non-jokers are same color
           const targetColor = nonJokers[0].color;
           if (!nonJokers.every(t => t.color === targetColor)) return false;

           // Sort non-jokers to check gaps
           const sortedNonJokers = [...nonJokers].sort((a, b) => a.value - b.value);

           let jokersAvailable = jokers.length;
           
           // Check gaps
           for (let i = 0; i < sortedNonJokers.length - 1; i++) {
              const current = sortedNonJokers[i].value;
              const next = sortedNonJokers[i+1].value;
              
              if (current === next) return false; // Duplicate
              
              const gap = next - current - 1; 
              
              if (gap > 0) {
                  if (jokersAvailable >= gap) {
                      jokersAvailable -= gap;
                  } else {
                      return false;
                  }
              }
           }
           return true;
        };

        return isGroup() || isRun();
      };

      const autoSortSet = (tiles, requireValid = true) => {
          // Try Run Sort (Strict)
          const runSorted = sortTiles(tiles, 'RUN');
          if (isValidSet(runSorted)) {
              // If it is a valid run, use intelligent organizer to place Jokers in gaps
              return organizeRun(tiles);
          }

          // Try Group Sort
          const groupSorted = sortTiles(tiles, 'GROUP');
          if (isValidSet(groupSorted)) return groupSorted;

          if (requireValid) return null;
          
          // If we don't require validity (e.g. during reorder drag), return a sensible default
          const colors = tiles.map(t => t.color).filter(c => c !== null);
          const mostCommonColor = colors.sort((a,b) => colors.filter(v => v===a).length - colors.filter(v => v===b).length).pop();
          const sameColorCount = tiles.filter(t => t.color === mostCommonColor).length;

          if (sameColorCount > tiles.length / 2) {
              return runSorted;
          }
          return groupSorted;
      };

      const validateMove = (existingTiles, newTiles) => {
          const combined = [...existingTiles, ...newTiles];
          return autoSortSet(combined);
      }

      const validateBoard = (board) => {
          return board.every(set => isValidSet(set.tiles));
      };

      const getSetDimensions = (tileCount) => {
          const tileWidth = 48;
          const gap = 1; // Tight gap
          const padding = 2; // Minimal padding
          
          const width = (tileCount * tileWidth) + ((tileCount - 1) * gap) + padding;
          const height = 80; // Tighter height
          return { width, height };
      };

      const doRectsIntersect = (r1, r2) => {
          // x, y are centers
          return !(r2.x - r2.w/2 > r1.x + r1.w/2 || 
                   r2.x + r2.w/2 < r1.x - r1.w/2 || 
                   r2.y - r2.h/2 > r1.y + r1.h/2 || 
                   r2.y + r2.h/2 < r1.y - r1.h/2);
      };

      const findFreePosition = (existingSets, tileCount) => {
          const { width, height } = getSetDimensions(tileCount);
          const buffer = 2; // Very tight buffer between sets
          const newRect = { x: 0, y: 0, w: width + buffer, h: height + buffer };
          
          // Spiral Search
          const a = 5; // Tight spiral gap
          let angle = 0;
          const step = 0.1; // Fine grained step
          let i = 0;

          // Safety break
          while (i < 5000) {
              // Calculate position
              const radius = a * angle;
              // Start from center
              newRect.x = i === 0 ? 0 : radius * Math.cos(angle);
              newRect.y = i === 0 ? 0 : radius * Math.sin(angle);

              // Check collision against all existing sets
              const hasCollision = existingSets.some(set => {
                  const dim = getSetDimensions(set.tiles.length);
                  return doRectsIntersect(newRect, { 
                      x: set.x, 
                      y: set.y, 
                      w: dim.width + buffer, 
                      h: dim.height + buffer 
                  });
              });

              if (!hasCollision) {
                  return { x: newRect.x, y: newRect.y };
              }

              angle += step;
              i++;
          }
          
          return { x: 0, y: 0 };
      };

      const compactBoardLogic = (sets) => {
          // 1. Sort sets by distance from center so inner ones settle first
          const sortedSets = [...sets].sort((a, b) => {
              const distA = Math.hypot(a.x, a.y);
              const distB = Math.hypot(b.x, b.y);
              return distA - distB;
          });

          const compactedSets = [];
          
          for (const set of sortedSets) {
              const { width, height } = getSetDimensions(set.tiles.length);
              const buffer = 2;
              const setRect = { x: 0, y: 0, w: width + buffer, h: height + buffer };
              
              // Target ray angle
              const angle = Math.atan2(set.y, set.x);
              
              // Max distance we need to check is current distance
              const maxDist = Math.hypot(set.x, set.y);
              
              // Ray cast from center (r=0) outwards
              let validX = set.x;
              let validY = set.y;
              
              // Step size for ray march
              const rayStep = 5;
              
              for (let r = 0; r <= maxDist; r += rayStep) {
                   setRect.x = r * Math.cos(angle);
                   setRect.y = r * Math.sin(angle);
                   
                   // Check if this position overlaps with ALREADY COMPACTED sets
                   const collision = compactedSets.some(placedSet => {
                       const dim = getSetDimensions(placedSet.tiles.length);
                       return doRectsIntersect(setRect, {
                           x: placedSet.x,
                           y: placedSet.y,
                           w: dim.width + buffer,
                           h: dim.height + buffer
                       });
                   });
                   
                   if (!collision) {
                       validX = setRect.x;
                       validY = setRect.y;
                       // We found the closest valid spot on the ray!
                       break;
                   }
              }
              
              compactedSets.push({ ...set, x: validX, y: validY });
          }
          
          return compactedSets;
      };

      // --- COMPONENTS ---

      const Tile = ({ 
        tile, 
        isSelected = false, 
        isDragging = false, 
        isNew = false,
        size = 'md' 
      }) => {
        const colorClass = tile.color ? COLOR_MAP[tile.color] : 'text-gray-800';
        
        // Dynamic sizing - Maximized Text
        const sizeClasses = {
          sm: 'w-8 h-12 text-xl',
          md: 'w-10 h-14 text-3xl md:w-12 md:h-16 md:text-4xl',
          lg: 'w-14 h-20 text-6xl',
        };

        const jokerSizes = {
            sm: 20,
            md: 32,
            lg: 40
        };

        const isSixOrNine = !tile.isJoker && (tile.value === 6 || tile.value === 9);

        return (
          <div
            className={clsx(
              "relative flex items-center justify-center rounded-md transition-transform duration-150 select-none cursor-pointer overflow-hidden",
              "bg-rummy-tile shadow-tile",
              isSelected ? "shadow-tile-selected -translate-y-1" : "",
              sizeClasses[size],
              // Border logic priority: Selection > New > Duplicate > Default
              isSelected ? "" : (
                  isNew ? "border-4 border-green-500 box-border" : (
                      tile.isDuplicate ? "border-4 border-gray-400 border-dashed box-border" : "border border-gray-100"
                  )
              ),
              isDragging ? "opacity-0" : "opacity-100" 
            )}
          >
              {/* Single Centered Content */}
              <div className={clsx("font-bold tracking-tighter flex items-center justify-center w-full h-full", colorClass)}>
                  {tile.isJoker ? (
                      <Ghost size={jokerSizes[size]} className="mx-auto" />
                  ) : (
                      <div className="flex flex-col items-center justify-center -mt-2">
                          <span>{tile.value}</span>
                          {isSixOrNine && (
                              <div className="w-full h-[3px] bg-current mt-[0px] opacity-60 rounded-full"></div>
                          )}
                      </div>
                  )}
              </div>
              
              {/* Subtle inner bevel/highlight for plastic look */}
              <div className="absolute inset-0 rounded-md shadow-[inset_0_1px_1px_rgba(255,255,255,0.6),inset_0_-1px_1px_rgba(0,0,0,0.1)] pointer-events-none"></div>
          </div>
        );
      };

      const PlayerRack = ({
        playerId,
        tiles,
        selectedTileIds,
        draggedTileIds,
        onSort,
        onDraw,
        onPlayNewSet,
        onDragStart,
        interactionMode,
        disabled = false,
        newTileId = null
      }) => {
        const isTop = playerId === 'TOP';
        const [windowWidth, setWindowWidth] = useState(window.innerWidth);
        const [offsetY, setOffsetY] = useState(0);

        // Constants for Layout
        const TILE_WIDTH = 50; 
        const TILE_HEIGHT = 70; 

        // Dynamic Calculation: 2 Rows or 3 Rows?
        const totalTiles = tiles.length;
        const dynamicRows = totalTiles > (RACK_ROWS * RACK_COLS) ? 3 : RACK_ROWS;
        
        // Dynamic Calculation: Columns?
        const maxTileX = tiles.reduce((max, t) => Math.max(max, t.rackX || 0), 0);
        const tileBasedCols = Math.ceil(tiles.length / dynamicRows);
        const dynamicCols = Math.max(RACK_COLS, tileBasedCols, maxTileX + 1);

        const RAW_GRID_WIDTH = dynamicCols * TILE_WIDTH;
        const RAW_GRID_HEIGHT = dynamicRows * TILE_HEIGHT;

        // Scaling Logic
        const BUTTON_PANEL_WIDTH = 90;
        const TOTAL_BUTTON_SPACE = (BUTTON_PANEL_WIDTH * 2) + 32;
        const availableWidth = windowWidth - TOTAL_BUTTON_SPACE;
        
        const scale = Math.min(1, availableWidth / RAW_GRID_WIDTH);

        const renderedWidth = RAW_GRID_WIDTH * scale;
        const renderedHeight = RAW_GRID_HEIGHT * scale;

        useEffect(() => {
          const handleResize = () => setWindowWidth(window.innerWidth);
          window.addEventListener('resize', handleResize);
          return () => window.removeEventListener('resize', handleResize);
        }, []);

        const gridMap = {};
        tiles.forEach(t => {
            const x = t.rackX ?? 0;
            const y = t.rackY ?? 0;
            gridMap[`${x},${y}`] = t;
        });

        const handleMoveVisualUp = (e) => {
            e.stopPropagation();
            setOffsetY(prev => prev + (isTop ? 10 : -10));
        };

        const handleMoveVisualDown = (e) => {
            e.stopPropagation();
            setOffsetY(prev => prev + (isTop ? -10 : 10));
        };

        return (
          <div 
            className={clsx(
              "flex items-center justify-between p-2 bg-gray-800/95 shadow-2xl backdrop-blur-sm z-40 w-full transition-all duration-300 select-none box-border absolute left-0 right-0",
              isTop ? "top-0 border-b-4 border-gray-700" : "bottom-0 border-t-4 border-gray-700",
              disabled ? "opacity-40 pointer-events-none grayscale" : "opacity-100"
            )}
            data-rack-id={playerId}
            style={{ 
                touchAction: 'none',
                transform: isTop 
                  ? `rotate(180deg) translateY(${offsetY}px)` 
                  : `translateY(${offsetY}px)`
            }} 
          >
            
            {/* LEFT: Controls (Pinned Left) */}
            <div className="flex flex-col gap-2 flex-shrink-0 z-20 w-[80px]">
                {!isTop && (
                  <div className="flex gap-1 mb-1 w-full">
                      <button 
                          onPointerDown={handleMoveVisualUp} 
                          className="flex-1 bg-gray-700 text-gray-300 rounded p-1 flex items-center justify-center shadow-md active:bg-gray-600 active:text-white transition-colors h-10"
                          title="Move Rack Up"
                      >
                          <ChevronUp size={24} />
                      </button>
                      <button 
                          onPointerDown={handleMoveVisualDown} 
                          className="flex-1 bg-gray-700 text-gray-300 rounded p-1 flex items-center justify-center shadow-md active:bg-gray-600 active:text-white transition-colors h-10"
                          title="Move Rack Down"
                      >
                          <ChevronDown size={24} />
                      </button>
                  </div>
                )}

                <button onClick={() => onSort('GROUP')} className="flex flex-col items-center justify-center p-2 bg-gray-700 rounded text-white active:bg-gray-600 hover:bg-gray-600 transition-colors h-16 w-full shadow-md">
                  <Layers size={24} />
                  <span className="text-[10px] font-bold mt-1">123</span>
                </button>
                <button onClick={() => onSort('RUN')} className="flex flex-col items-center justify-center p-2 bg-gray-700 rounded text-white active:bg-gray-600 hover:bg-gray-600 transition-colors h-16 w-full shadow-md">
                  <Palette size={24} />
                  <span className="text-[10px] font-bold mt-1">Colors</span>
                </button>
            </div>

            {/* CENTER: Tile Grid Container (Flex Grow) */}
            <div className="flex-grow flex justify-center items-center overflow-hidden h-full">
              <div 
                  className="relative overflow-visible"
                  style={{
                      width: renderedWidth,
                      height: renderedHeight
                  }}
              >
                  <div 
                      className="absolute top-0 left-0 origin-top-left"
                      style={{ 
                          width: RAW_GRID_WIDTH,
                          height: RAW_GRID_HEIGHT,
                          transform: `scale(${scale})`,
                      }}
                  >
                      {/* Render Grid */}
                      {Array.from({ length: dynamicRows }).map((_, r) => (
                          Array.from({ length: dynamicCols }).map((_, c) => {
                              const tile = gridMap[`${c},${r}`];
                              return (
                                  <div
                                      key={`${c}-${r}`}
                                      data-slot-x={c}
                                      data-slot-y={r}
                                      className="absolute w-[48px] h-[64px] rounded border-transparent"
                                      style={{
                                          left: c * 50,
                                          top: r * 70
                                      }}
                                  >
                                      {tile && (
                                          <div
                                              onPointerDown={(e) => {
                                                  if (interactionMode === 'IDLE' || interactionMode === 'REORDER_BOARD') {
                                                      onDragStart(e, tile, `RACK_${playerId}`);
                                                  }
                                              }}
                                              className="touch-none w-full h-full"
                                          >
                                              <Tile
                                                  tile={tile}
                                                  isSelected={selectedTileIds.includes(tile.id)}
                                                  isDragging={draggedTileIds.includes(tile.id)}
                                                  isNew={tile.id === newTileId}
                                                  size="md"
                                              />
                                          </div>
                                      )}
                                  </div>
                              );
                          })
                      ))}
                  </div>
              </div>
            </div>

            {/* RIGHT: Action Controls (Pinned Right) */}
            <div className="flex flex-col gap-2 flex-shrink-0 z-20 w-[80px]">
                 <button 
                   onClick={onDraw} 
                   className="flex flex-col items-center justify-center p-2 bg-gray-600 rounded text-white font-bold text-sm active:scale-95 transition-transform h-14 w-full shadow-lg"
                  >
                   <Download size={20} className="mb-1" />
                   <span className="text-[10px]">DRAW</span>
                 </button>
                 <button 
                   onClick={onPlayNewSet} 
                   className="flex flex-col items-center justify-center p-2 bg-green-700 rounded text-white font-bold text-sm active:scale-95 transition-transform shadow-lg h-14 w-full"
                 >
                   <PlusSquare size={20} className="mb-1" />
                   <span className="text-[10px]">PLAY SET</span>
                 </button>
            </div>

          </div>
        );
      };

      const GameBoard = ({ 
          sets, 
          interactionMode, 
          gamePhase,
          setupState,
          draggedTileIds,
          hasSelectedTiles,
          onSetClick, 
          onToggleReorder,
          onResetBoard,
          onResetGame,
          onDragStart,
          onSetupDraw,
          onStartGame,
          onSetDragStart,
          onSetRotate,
          onCycleRotate,
          onCompactBoard,
          onToggleSplit
      }) => {
        const isReordering = interactionMode === 'REORDER_BOARD';
        const isSplitting = interactionMode === 'SPLIT_SET';
        const boardRef = useRef(null);
        const [boardScale, setBoardScale] = useState(1);
        const allSetsValid = sets.every(s => isValidSet(s.tiles));

        // Auto-Zoom Logic
        useEffect(() => {
            if (sets.length === 0) {
                setBoardScale(1);
                return;
            }

            let maxDistX = 0;
            let maxDistY = 0;

            sets.forEach(set => {
                const { width, height } = getSetDimensions(set.tiles.length);
                const distX = Math.abs(set.x) + width / 2;
                const distY = Math.abs(set.y) + height / 2;
                if (distX > maxDistX) maxDistX = distX;
                if (distY > maxDistY) maxDistY = distY;
            });

            const safeWidth = (window.innerWidth / 2) - 60; // Reduced padding
            const safeHeight = (window.innerHeight / 2) - 140;

            let scaleX = 1;
            let scaleY = 1;

            if (maxDistX > safeWidth) scaleX = safeWidth / maxDistX;
            if (maxDistY > safeHeight) scaleY = safeHeight / maxDistY;

            setBoardScale(Math.max(0.4, Math.min(1, Math.min(scaleX, scaleY))));

        }, [sets, window.innerWidth, window.innerHeight]);

        if (gamePhase === 'SETUP') {
            return (
                <div className="flex-1 bg-rummy-board relative flex flex-col items-center justify-center overflow-hidden shadow-inner">
                   {/* Texture overlay */}
                   <div className="absolute inset-0 opacity-20 pointer-events-none z-0" style={{ backgroundImage: 'radial-gradient(#ffffff 1px, transparent 1px)', backgroundSize: '20px 20px' }}></div>

                   {/* Messy Pile Visuals */}
                   <div className="relative w-64 h-64 flex items-center justify-center">
                       {[...Array(6)].map((_, i) => (
                           <div 
                              key={i}
                              className="absolute w-12 h-16 bg-rummy-tile shadow-tile border border-gray-300 rounded"
                              style={{ 
                                  transform: `rotate(${Math.random() * 360}deg) translate(${Math.random() * 40 - 20}px, ${Math.random() * 40 - 20}px)`,
                                  zIndex: 0
                              }}
                           />
                       ))}
                       
                       {setupState.topCard && setupState.bottomCard && (
                           <button 
                              onClick={onStartGame}
                              className="absolute z-50 bg-green-600 text-white font-bold text-xl px-8 py-4 rounded-full shadow-2xl animate-bounce flex items-center gap-2 hover:bg-green-500 transition-colors"
                           >
                               <Play fill="currentColor" /> Start Game
                           </button>
                       )}
                   </div>

                   {/* Top Player Draw Area */}
                   <div className="absolute top-20 rotate-180 flex flex-col items-center gap-4">
                       {setupState.topCard ? (
                           <div className="scale-150"><Tile tile={setupState.topCard} /></div>
                       ) : (
                           <button 
                              onClick={() => onSetupDraw('TOP')}
                              className="bg-gray-800 text-white px-6 py-3 rounded-lg shadow-xl font-bold active:scale-95 transition-transform"
                           >
                               Draw for Start
                           </button>
                       )}
                   </div>

                   {/* Bottom Player Draw Area */}
                   <div className="absolute bottom-20 flex flex-col items-center gap-4">
                       {setupState.bottomCard ? (
                           <div className="scale-150"><Tile tile={setupState.bottomCard} /></div>
                       ) : (
                           <button 
                              onClick={() => onSetupDraw('BOTTOM')}
                              className="bg-gray-800 text-white px-6 py-3 rounded-lg shadow-xl font-bold active:scale-95 transition-transform"
                           >
                               Draw for Start
                           </button>
                       )}
                   </div>
                </div>
            );
        }

        return (
          <div 
              id="game-board-container"
              ref={boardRef}
              className="flex-1 bg-rummy-board relative overflow-hidden flex flex-col shadow-inner select-none"
              style={{ touchAction: isReordering ? 'none' : 'auto' }}
          >
            <div className="absolute inset-0 opacity-20 pointer-events-none z-0" style={{ backgroundImage: 'radial-gradient(#ffffff 1px, transparent 1px)', backgroundSize: '20px 20px' }}></div>

            {/* LEFT HUD: New Game Button (Edge Tab) */}
            <div className="absolute top-1/2 left-0 transform -translate-y-1/2 z-20 flex flex-col gap-2">
                  {!isReordering && (
                      <button
                          onClick={(e) => { e.stopPropagation(); onResetGame(); }}
                          className="w-12 py-8 rounded-r-xl shadow-lg font-bold text-xs tracking-widest bg-gray-800 text-white border-l-0 border border-gray-600 hover:translate-x-1 transition-transform flex items-center justify-center"
                          title="Start New Game"
                      >
                          {/* Writing Mode vertical-rl + Rotate 180 makes text read Bottom-to-Top */}
                          <span className="[writing-mode:vertical-rl] rotate-180 whitespace-nowrap">NEW GAME</span>
                      </button>
                  )}
            </div>

            {/* RIGHT HUD: Controls (Edge Tabs) */}
            <div className="absolute top-1/2 right-0 transform -translate-y-1/2 z-20 flex flex-col gap-12 items-end">
                
                {/* Top Group: Reorder / Rotate */}
                <div className="flex flex-col gap-2">
                  {isReordering && (
                      <button
                          onClick={(e) => { e.stopPropagation(); onResetBoard(); }}
                          className="w-12 py-6 rounded-l-xl shadow-lg font-bold text-xs tracking-widest bg-yellow-600 text-white hover:-translate-x-1 transition-transform flex items-center justify-center"
                      >
                          <span className="[writing-mode:vertical-rl] whitespace-nowrap">RESET</span>
                      </button>
                  )}

                  <button 
                      onClick={(e) => { e.stopPropagation(); onToggleReorder(); }}
                      className={clsx(
                          "w-12 py-6 rounded-l-xl shadow-lg font-bold text-xs tracking-widest hover:-translate-x-1 transition-transform flex items-center justify-center",
                          isReordering 
                              ? (allSetsValid ? "bg-green-600 text-white" : "bg-red-600 text-white animate-pulse")
                              : "bg-blue-600 text-white"
                      )}
                  >
                      <span className="[writing-mode:vertical-rl] whitespace-nowrap">{isReordering ? "DONE" : "REORDER"}</span>
                  </button>

                  <button
                      onClick={(e) => { e.stopPropagation(); onCycleRotate(); }}
                      className="w-12 py-6 rounded-l-xl shadow-lg font-bold text-xs tracking-widest bg-indigo-600 text-white hover:-translate-x-1 transition-transform flex items-center justify-center"
                      title="Rotate Orientation"
                  >
                      <span className="[writing-mode:vertical-rl] whitespace-nowrap">ROTATE</span>
                  </button>
                </div>

                {/* Bottom Group: Compact / Split */}
                <div className="flex flex-col gap-2">
                   <button
                      onClick={(e) => { e.stopPropagation(); onCompactBoard(); }}
                      className="w-12 py-6 rounded-l-xl shadow-lg font-bold text-xs tracking-widest bg-yellow-500 text-black hover:-translate-x-1 transition-transform flex items-center justify-center"
                      title="Compact Board"
                  >
                      <span className="[writing-mode:vertical-rl] whitespace-nowrap">COMPACT</span>
                  </button>

                  <button
                      onClick={(e) => { e.stopPropagation(); onToggleSplit(); }}
                      className={clsx(
                          "w-12 py-6 rounded-l-xl shadow-lg font-bold text-xs tracking-widest hover:-translate-x-1 transition-transform flex items-center justify-center",
                          isSplitting 
                              ? "bg-green-500 text-white ring-2 ring-white" 
                              : "bg-green-600 text-white"
                      )}
                      title="Split Set"
                  >
                      <span className="[writing-mode:vertical-rl] whitespace-nowrap">SPLIT</span>
                  </button>
                </div>
            </div>

            <div 
              id="game-board" 
              className="absolute left-1/2 top-1/2 w-0 h-0 overflow-visible z-10 transition-transform duration-500 ease-out"
              style={{ transform: `scale(${boardScale})` }}
            >
              {sets.map((set) => {
                  const isValid = isValidSet(set.tiles);
                  const baseRotation = set.orientation === 'TOP' ? 180 : 0;
                  const randomRotation = set.rotation || 0;
                  const x = set.x || 0;
                  const y = set.y || 0;
                  
                  return (
                    <div 
                      key={set.id}
                      data-set-id={set.id}
                      onPointerUp={(e) => onSetClick(e, set.id)}
                      onPointerDown={(e) => {
                         if (!isReordering && !isSplitting && !hasSelectedTiles) {
                             onSetDragStart(e, set.id);
                         }
                      }}
                      style={{
                          transform: `translate(-50%, -50%) translate(${x}px, ${y}px) rotate(${baseRotation + randomRotation}deg)`,
                          position: 'absolute',
                          left: 0,
                          top: 0
                      }}
                      className={clsx(
                        "bg-black/10 rounded-xl p-3 flex gap-1 transition-colors duration-200 border-2 items-center min-w-max",
                        isReordering 
                          ? (isValid ? "border-white/50 border-dashed" : "border-red-500 bg-red-900/20 border-dashed") 
                          : (!hasSelectedTiles && !isSplitting ? "border-transparent hover:bg-white/5 cursor-move" : "border-transparent hover:bg-white/5"),
                        isSplitting && set.tiles.length >= 6 ? "cursor-crosshair hover:bg-green-900/30 border-green-500/50 border-dashed" : ""
                      )}
                    >
                      {/* Reorder Mode Handles */}
                      {isReordering && (
                          <>
                              {/* Move Handle */}
                              <div 
                                  onPointerDown={(e) => onSetDragStart(e, set.id)}
                                  className="absolute -top-10 left-1/2 -translate-x-[120%] w-10 h-10 bg-blue-600 rounded-full flex items-center justify-center shadow-lg cursor-move active:scale-95 transition-transform z-30"
                              >
                                  <Move size={20} className="text-white" />
                              </div>
                              
                              {/* Rotate Handle */}
                              <div 
                                  onPointerDown={(e) => { e.stopPropagation(); onSetRotate(set.id); }}
                                  className="absolute -top-10 left-1/2 translate-x-[20%] w-10 h-10 bg-yellow-600 rounded-full flex items-center justify-center shadow-lg cursor-pointer active:scale-95 transition-transform z-30"
                              >
                                  <RotateCcw size={20} className="text-white" />
                              </div>
                          </>
                      )}

                      {set.tiles.map((tile) => (
                        <div 
                          key={tile.id}
                          onPointerDown={(e) => {
                              if (isReordering) {
                                  onDragStart(e, tile, set.id);
                              }
                          }}
                          className={clsx(isReordering ? "cursor-grab active:cursor-grabbing" : "")}
                        >
                            <Tile 
                              tile={tile} 
                              size="md"
                              isDragging={draggedTileIds.includes(tile.id)}
                            />
                        </div>
                      ))}
                    </div>
                  );
              })}
            </div>
          </div>
        );
      };

      // --- APP COMPONENT ---

      const DEFAULT_STATE = {
          gamePhase: 'SETUP',
          deck: [],
          board: [],
          boardSnapshot: null,
          rackSnapshots: null,
          playerTopHand: [],
          playerBottomHand: [],
          playerTopSort: 'RUN', 
          playerBottomSort: 'RUN', 
          selectedTileIds: { TOP: [], BOTTOM: [] },
          activePlayer: null,
          interactionMode: 'IDLE',
          activeDrags: {},
          setupState: {
              topCard: null,
              bottomCard: null
          },
          lastDrawnTileId: {
              TOP: null,
              BOTTOM: null
          }
      };

      const App = () => {
        const [gameState, setGameState] = useState(() => {
            // Hydrate from LocalStorage
            const saved = localStorage.getItem('rummikub_state');
            if (saved) {
                try {
                    const parsed = JSON.parse(saved);
                    // Migration: Ensure board sets have x,y and createdBy
                    if (parsed.board) {
                        parsed.board = parsed.board.map((s) => ({
                            ...s,
                            x: s.x ?? 0,
                            y: s.y ?? 0,
                            createdBy: s.createdBy ?? s.orientation // Backfill createdBy if missing
                        }));
                    }
                    // Migration: Ensure tiles have rack positions if missing
                    ['playerTopHand', 'playerBottomHand'].forEach(key => {
                        if (parsed[key]) {
                            parsed[key] = sortHand(parsed[key], 'RUN'); 
                        }
                    });
                    
                    // Migration: Convert old array selection to object selection
                    if (Array.isArray(parsed.selectedTileIds)) {
                        parsed.selectedTileIds = { TOP: [], BOTTOM: [] };
                    }
                    
                    // Migration: Convert old dragState to activeDrags
                    if (parsed.dragState) {
                        parsed.activeDrags = {};
                        delete parsed.dragState;
                    }

                    return parsed;
                } catch (e) {
                    console.error("Failed to load state", e);
                }
            }
            return DEFAULT_STATE;
        });

        const [showNewGameModal, setShowNewGameModal] = useState(false);
        
        // Store offsets for EACH active pointer
        const dragOffsetsRef = useRef({});

        // Persistence Effect
        useEffect(() => {
            localStorage.setItem('rummikub_state', JSON.stringify(gameState));
        }, [gameState]);

        // Initialize Deck (Only runs on initial mount if state is empty)
        useEffect(() => {
          if (gameState.deck.length === 0 && gameState.gamePhase === 'SETUP' && !gameState.setupState.topCard) {
              const deck = generateDeck();
              setGameState(prev => ({ ...prev, deck }));
          }
        }, []); // Only run once on mount or explicitly manually

        // --- Helpers ---
        const getRandomRotation = () => (Math.random() * 4) - 2;

        // --- Global Reset ---
        
        const handleResetGame = () => {
            setShowNewGameModal(true);
        };

        const confirmNewGameReset = () => {
            localStorage.removeItem('rummikub_state');
            // Important: Create a fresh state object with a new deck immediately
            // to prevent stale state or useEffect conflicts.
            const newDeck = generateDeck();
            setGameState({
                ...DEFAULT_STATE,
                deck: newDeck,
                // Explicitly reset these to ensure 'SETUP' phase is rendered
                gamePhase: 'SETUP',
                setupState: { topCard: null, bottomCard: null }
            });
            setShowNewGameModal(false);
        };

        // --- Setup Phase Handlers ---

        const handleSetupDraw = (pid) => {
            setGameState(prev => {
                if (prev.gamePhase !== 'SETUP') return prev;
                if (pid === 'TOP' && prev.setupState.topCard) return prev;
                if (pid === 'BOTTOM' && prev.setupState.bottomCard) return prev;

                const newDeck = [...prev.deck];
                const randomIndex = Math.floor(Math.random() * newDeck.length);
                const drawnTile = newDeck.splice(randomIndex, 1)[0];

                return {
                    ...prev,
                    deck: newDeck,
                    setupState: {
                        ...prev.setupState,
                        topCard: pid === 'TOP' ? drawnTile : prev.setupState.topCard,
                        bottomCard: pid === 'BOTTOM' ? drawnTile : prev.setupState.bottomCard
                    }
                };
            });
        };

        const handleStartGame = () => {
            const fullDeck = generateDeck();
            const hand1 = fullDeck.splice(0, 14);
            const hand2 = fullDeck.splice(0, 14);

            setGameState(prev => ({
                ...prev,
                gamePhase: 'PLAYING',
                deck: fullDeck,
                playerTopHand: sortHand(hand1, prev.playerTopSort),
                playerBottomHand: sortHand(hand2, prev.playerBottomSort),
                setupState: { topCard: null, bottomCard: null },
                lastDrawnTileId: { TOP: null, BOTTOM: null }
            }));
        };

        // --- Pointer/Drag Events (Multi-Touch Support) ---

        const handleDragStart = (e, tile, sourceSetId) => {
          e.preventDefault();
          e.stopPropagation();
          
          // Do not allow dragging if this tile is already being dragged by another pointer
          if (Object.values(gameState.activeDrags).some(d => d.tileId === tile.id)) {
              return;
          }

          const rect = e.currentTarget.getBoundingClientRect();
          
          // Store offset for smooth drag specific to this pointer
          dragOffsetsRef.current[e.pointerId] = {
              x: e.clientX - rect.left,
              y: e.clientY - rect.top
          };

          setGameState(prev => ({
              ...prev,
              activeDrags: {
                  ...prev.activeDrags,
                  [e.pointerId]: {
                      isDragging: false, // Wait for move threshold
                      tileId: tile.id,
                      sourceSetId,
                      x: e.clientX,
                      y: e.clientY,
                      startX: e.clientX,
                      startY: e.clientY,
                      tileData: tile,
                      draggingSetId: null,
                      initialSetPos: null
                  }
              }
          }));
        };

        const handleSetDragStart = (e, setId) => {
            e.preventDefault();
            e.stopPropagation();
            
            // Prevent double drag of same set
            if (Object.values(gameState.activeDrags).some(d => d.draggingSetId === setId)) {
                return;
            }

            const set = gameState.board.find(s => s.id === setId);
            if (!set) return;

            // For sets, we track the initial click relative to the set center isn't critical 
            // because we move by delta, but let's init the offset anyway for consistency
            dragOffsetsRef.current[e.pointerId] = { x: 0, y: 0 };

            setGameState(prev => ({
                ...prev,
                activeDrags: {
                    ...prev.activeDrags,
                    [e.pointerId]: {
                        isDragging: true, // Immediate for handles
                        draggingSetId: setId,
                        tileId: null, // Clear tile drag
                        initialSetPos: { x: set.x, y: set.y },
                        startX: e.clientX,
                        startY: e.clientY,
                        x: e.clientX,
                        y: e.clientY,
                        sourceSetId: null,
                        tileData: null
                    }
                }
            }));
        };

        const handleSetRotate = (setId) => {
            setGameState(prev => ({
                ...prev,
                board: prev.board.map(s => {
                    if (s.id === setId) {
                        return {
                            ...s,
                            orientation: s.orientation === 'TOP' ? 'BOTTOM' : 'TOP'
                        };
                    }
                    return s;
                })
            }));
        };

        // --- Global Rotation Handlers ---
        const handleCycleRotate = () => {
          setGameState(prev => {
              const topCount = prev.board.filter(s => s.orientation === 'TOP').length;
              const target = topCount > prev.board.length / 2 ? 'BOTTOM' : 'TOP';
              return {
                  ...prev,
                  board: prev.board.map(s => ({ ...s, orientation: target }))
              };
          });
        };
        
        const handleCompactBoard = () => {
            setGameState(prev => ({
                ...prev,
                board: compactBoardLogic(prev.board)
            }));
        };

        const handlePointerMove = (e) => {
          e.preventDefault();
          
          // Check if this pointer is active
          const dragData = gameState.activeDrags[e.pointerId];
          if (!dragData) return;

          const { tileId, isDragging, startX, startY, draggingSetId, initialSetPos } = dragData;

          // 1. SET DRAGGING (Immediate)
          if (isDragging && draggingSetId && initialSetPos) {
              const dx = e.clientX - startX;
              const dy = e.clientY - startY;

              setGameState(prev => ({
                  ...prev,
                  board: prev.board.map(s => {
                      if (s.id === draggingSetId) {
                          return {
                              ...s,
                              x: initialSetPos.x + dx,
                              y: initialSetPos.y + dy
                          };
                      }
                      return s;
                  }),
                  activeDrags: {
                      ...prev.activeDrags,
                      [e.pointerId]: {
                          ...dragData,
                          x: e.clientX,
                          y: e.clientY
                      }
                  }
              }));
              return;
          }

          // 2. TILE DRAGGING (Threshold)
          if (tileId) {
              if (!isDragging) {
                  const dist = Math.hypot(e.clientX - startX, e.clientY - startY);
                  if (dist > 5) { // 5px threshold for drag vs tap
                      setGameState(prev => ({
                          ...prev,
                          activeDrags: {
                              ...prev.activeDrags,
                              [e.pointerId]: {
                                  ...dragData,
                                  isDragging: true,
                                  x: e.clientX,
                                  y: e.clientY
                              }
                          }
                      }));
                  }
              } else {
                  // Continue Drag
                  setGameState(prev => ({
                      ...prev,
                      activeDrags: {
                          ...prev.activeDrags,
                          [e.pointerId]: {
                              ...dragData,
                              x: e.clientX,
                              y: e.clientY
                          }
                      }
                  }));
              }
          }
        };

        const handlePointerUp = (e) => {
          const dragData = gameState.activeDrags[e.pointerId];
          if (!dragData) return;

          // Clean up offset
          delete dragOffsetsRef.current[e.pointerId];

          const { isDragging, tileId, tileData, sourceSetId, draggingSetId } = dragData;

          // Helper to cleanup this specific drag
          const cleanupDrag = (state) => {
              const newDrags = { ...state.activeDrags };
              delete newDrags[e.pointerId];
              return { ...state, activeDrags: newDrags };
          };

          // If we were dragging a whole set, just stop
          if (draggingSetId) {
              setGameState(prev => cleanupDrag(prev));
              return;
          }

          if (!tileId || !tileData) {
              setGameState(prev => cleanupDrag(prev));
              return;
          }

          // --- CASE 1: TAP / CLICK (Selection) ---
          if (!isDragging) {
              // Determine owner for selection logic
              const owner = sourceSetId?.includes('TOP') ? 'TOP' : (sourceSetId?.includes('BOTTOM') ? 'BOTTOM' : null);
              if (owner) {
                  handleTileClick(tileId, owner);
              }
              setGameState(prev => cleanupDrag(prev));
              return;
          }

          // --- CASE 2: DRAG DROP ---
          // Hit Test to find drop target
          const elements = document.elementsFromPoint(e.clientX, e.clientY);
          
          // Check Rack Drop first
          const targetRackElement = elements.find(el => el.hasAttribute('data-rack-id'));
          const targetRackId = targetRackElement?.getAttribute('data-rack-id');

          // Check Slot Drop (specific x,y on rack)
          const targetSlotElement = elements.find(el => el.hasAttribute('data-slot-x'));

          // Check Board Set Drop
          const targetSetElement = elements.find(el => el.hasAttribute('data-set-id'));
          const targetSetId = targetSetElement?.getAttribute('data-set-id');

          setGameState(prev => {
              // --- RACK DROP (Reorder or Return to Rack) ---
              if (targetRackId) {
                   const isTop = targetRackId === 'TOP';
                   const currentHand = isTop ? [...prev.playerTopHand] : [...prev.playerBottomHand];
                   
                   // Remove from source hand if it exists there
                   let updatedHand = currentHand.filter(t => t.id !== tileId);
                   
                   // Determine new position
                   let newX = 0;
                   let newY = 0;

                   if (targetSlotElement) {
                       newX = parseInt(targetSlotElement.getAttribute('data-slot-x') || '0');
                       newY = parseInt(targetSlotElement.getAttribute('data-slot-y') || '0');
                   } else {
                       const pos = findFreeRackSlot(updatedHand);
                       newX = pos.x;
                       newY = pos.y;
                   }

                   // Handle Collision (Swap/Shift)
                   const existingOccupantIndex = updatedHand.findIndex(t => t.rackX === newX && t.rackY === newY);
                   const tileToPlace = { ...tileData, rackX: newX, rackY: newY };
                   
                   if (existingOccupantIndex !== -1) {
                       // Move occupant to first available free slot
                       const occupant = updatedHand[existingOccupantIndex];
                       updatedHand.splice(existingOccupantIndex, 1);
                       
                       // Recalculate free slot for occupant
                       const occupiedSet = new Set();
                       occupiedSet.add(`${newX},${newY}`);
                       updatedHand.forEach(t => occupiedSet.add(`${t.rackX},${t.rackY}`));

                       let freeX = 0, freeY = 0;
                       const dynCols = Math.max(10, Math.ceil(updatedHand.length / (updatedHand.length > 20 ? 3 : 2)));

                       outerLoop: for(let r=0; r<3; r++) { 
                           for(let c=0; c<dynCols+2; c++) {
                               if (!occupiedSet.has(`${c},${r}`)) {
                                   freeX = c; freeY = r;
                                   break outerLoop;
                               }
                           }
                       }
                       
                       occupant.rackX = freeX;
                       occupant.rackY = freeY;
                       updatedHand.push(occupant);
                       updatedHand.push(tileToPlace);
                   } else {
                       updatedHand.push(tileToPlace);
                   }

                   // If dragging from Board, remove from board set
                   let newBoard = [...prev.board];
                   if (sourceSetId && sourceSetId.indexOf('RACK') === -1) {
                       const setIndex = newBoard.findIndex(s => s.id === sourceSetId);
                       if (setIndex !== -1) {
                           const setTiles = newBoard[setIndex].tiles.filter(t => t.id !== tileId);
                           if (setTiles.length === 0) {
                               newBoard.splice(setIndex, 1);
                           } else {
                               newBoard[setIndex] = { ...newBoard[setIndex], tiles: setTiles };
                           }
                       }
                   }

                   const stateAfterDrop = {
                       ...prev,
                       board: newBoard,
                       playerTopHand: isTop ? updatedHand : prev.playerTopHand,
                       playerBottomHand: !isTop ? updatedHand : prev.playerBottomHand,
                       lastDrawnTileId: {
                           ...prev.lastDrawnTileId,
                           [isTop ? 'TOP' : 'BOTTOM']: null
                       }
                   };
                   return cleanupDrag(stateAfterDrop);
              }

              // --- BOARD MANIPULATION (Reorder Mode) ---
              if (prev.interactionMode === 'REORDER_BOARD') {
                  let newBoard = [...prev.board];
                  let newTopHand = [...prev.playerTopHand];
                  let newBottomHand = [...prev.playerBottomHand];
                  let sourceWasRack = false;
                  
                  // 1. Remove from Source (Rack or Board)
                  if (sourceSetId && sourceSetId.startsWith('RACK_')) {
                      sourceWasRack = true;
                      const isTop = sourceSetId === 'RACK_TOP';
                      if (isTop) {
                          newTopHand = newTopHand.filter(t => t.id !== tileId);
                      } else {
                          newBottomHand = newBottomHand.filter(t => t.id !== tileId);
                      }
                  } else {
                      // Remove from board source
                      const sourceSetIndex = newBoard.findIndex(s => s.id === sourceSetId);
                      if (sourceSetIndex !== -1) {
                          let sourceTiles = [...newBoard[sourceSetIndex].tiles];
                          sourceTiles = sourceTiles.filter(t => t.id !== tileId);
                          
                          if (sourceTiles.length === 0) {
                              newBoard.splice(sourceSetIndex, 1);
                          } else {
                              newBoard[sourceSetIndex] = { ...newBoard[sourceSetIndex], tiles: sourceTiles };
                          }
                      }
                  }

                  // 2. Add to Target
                  if (targetSetId) {
                      const targetIndex = newBoard.findIndex(s => s.id === targetSetId);
                      if (targetIndex !== -1) {
                          let targetTiles = [...newBoard[targetIndex].tiles, tileData];
                          // In reorder mode, auto-sort but do NOT require validity
                          const sorted = autoSortSet(targetTiles, false); 
                          newBoard[targetIndex] = { ...newBoard[targetIndex], tiles: sorted || targetTiles };
                      }
                  } else {
                      // New Set
                      const boardEl = document.getElementById('game-board-container');
                      let dropX = 0;
                      let dropY = 0;
                      
                      if (boardEl) {
                          const rect = boardEl.getBoundingClientRect();
                          const centerX = rect.left + rect.width / 2;
                          const centerY = rect.top + rect.height / 2;
                          dropX = e.clientX - centerX;
                          dropY = e.clientY - centerY;
                      }

                      // If coming from rack, use that player's orientation. 
                      // If from board, default to BOTTOM (standard)
                      let orientation = 'BOTTOM';
                      if (sourceWasRack) {
                          orientation = sourceSetId === 'RACK_TOP' ? 'TOP' : 'BOTTOM';
                      }

                      newBoard.push({ 
                          id: uuidv4(), 
                          tiles: [tileData], 
                          orientation: orientation,
                          createdBy: orientation,
                          rotation: getRandomRotation(),
                          x: dropX,
                          y: dropY
                      });
                  }

                  const stateAfterDrop = {
                      ...prev,
                      board: newBoard,
                      playerTopHand: newTopHand,
                      playerBottomHand: newBottomHand,
                  };
                  return cleanupDrag(stateAfterDrop);
              }

              return cleanupDrag(prev);
          });
        };

        // --- Handlers ---

        const getActiveHand = useCallback((pid) => {
          return pid === 'TOP' ? gameState.playerTopHand : gameState.playerBottomHand;
        }, [gameState.playerTopHand, gameState.playerBottomHand]);

        const handleTileClick = (tileId, owner) => {
          setGameState(prev => {
            const currentSelection = prev.selectedTileIds[owner];
            const isSelected = currentSelection.includes(tileId);
            
            const newSelection = isSelected 
              ? currentSelection.filter(id => id !== tileId)
              : [...currentSelection, tileId];

            return {
              ...prev,
              activePlayer: owner, // Last player to click becomes "active" for turn-based logic
              selectedTileIds: {
                  ...prev.selectedTileIds,
                  [owner]: newSelection
              }
            };
          });
        };

        const handleSort = (pid, method) => {
          const hand = getActiveHand(pid);
          const sorted = sortHand(hand, method);
          
          setGameState(prev => ({
              ...prev,
              playerTopHand: pid === 'TOP' ? sorted : prev.playerTopHand,
              playerBottomHand: pid === 'BOTTOM' ? sorted : prev.playerBottomHand,
              playerTopSort: pid === 'TOP' ? method : prev.playerTopSort,
              playerBottomSort: pid === 'BOTTOM' ? method : prev.playerBottomSort,
              lastDrawnTileId: {
                  ...prev.lastDrawnTileId,
                  [pid]: null
              }
          }));
        };

        const handleDraw = (pid) => {
          setGameState(prev => {
              if (prev.deck.length === 0) return prev;
              
              const newDeck = [...prev.deck];
              const drawnTile = newDeck.pop();
              
              const hand = pid === 'TOP' ? prev.playerTopHand : prev.playerBottomHand;
              const pos = findFreeRackSlot(hand);
              drawnTile.rackX = pos.x;
              drawnTile.rackY = pos.y;
              
              const newHand = [...hand, drawnTile];

              return {
                  ...prev,
                  deck: newDeck,
                  playerTopHand: pid === 'TOP' ? newHand : prev.playerTopHand,
                  playerBottomHand: pid === 'BOTTOM' ? newHand : prev.playerBottomHand,
                  activePlayer: pid,
                  lastDrawnTileId: {
                      ...prev.lastDrawnTileId,
                      [pid]: drawnTile.id
                  }
              };
          });
        };

        const handlePlayNewSet = (pid) => {
          const hand = getActiveHand(pid);
          const selection = gameState.selectedTileIds[pid];
          const selectedTiles = hand.filter(t => selection.includes(t.id));

          if (selectedTiles.length === 0) return;

          const isReordering = gameState.interactionMode === 'REORDER_BOARD';
          const requireValid = !isReordering;

          const candidateSet = autoSortSet(selectedTiles, requireValid);
          
          if (candidateSet) {
              const newHand = hand.filter(t => !selection.includes(t.id));
              const pos = findFreePosition(gameState.board, candidateSet.length);

              setGameState(prev => ({
                  ...prev,
                  board: [...prev.board, { 
                      id: uuidv4(), 
                      tiles: candidateSet, 
                      orientation: pid,
                      createdBy: pid,
                      rotation: getRandomRotation(),
                      x: pos.x,
                      y: pos.y
                  }],
                  selectedTileIds: {
                      ...prev.selectedTileIds,
                      [pid]: [] // Clear only this player's selection
                  },
                  playerTopHand: pid === 'TOP' ? newHand : prev.playerTopHand,
                  playerBottomHand: pid === 'BOTTOM' ? newHand : prev.playerBottomHand,
                  activePlayer: pid,
                  lastDrawnTileId: {
                      ...prev.lastDrawnTileId,
                      [pid]: null
                  }
              }));
          }
        };

        const handleSetClick = (e, setId) => {
            if (gameState.interactionMode === 'SPLIT_SET') {
                // --- SPLIT LOGIC ---
                const setIndex = gameState.board.findIndex(s => s.id === setId);
                if (setIndex === -1) return;
                const set = gameState.board[setIndex];
                
                if (set.tiles.length < 6) return; // Min tiles to split

                const setElement = e.currentTarget;
                const clickX = e.clientX;
                const clickY = e.clientY;

                // Find gap index
                const tileElements = Array.from(setElement.children).filter(child => !child.classList.contains('absolute')); 
                
                let minDistance = Infinity;
                let splitIndex = -1;

                for (let i = 1; i < tileElements.length; i++) {
                    const rectPrev = tileElements[i-1].getBoundingClientRect();
                    const rectNext = tileElements[i].getBoundingClientRect();
                    
                    const midX = (rectPrev.right + rectNext.left) / 2;
                    const midY = (rectPrev.top + rectPrev.height/2 + rectNext.top + rectNext.height/2) / 2;
                    
                    const dist = Math.hypot(clickX - midX, clickY - midY);
                    
                    if (dist < minDistance) {
                        minDistance = dist;
                        splitIndex = i;
                    }
                }
                
                if (splitIndex !== -1) {
                    const tiles1 = set.tiles.slice(0, splitIndex);
                    const tiles2 = set.tiles.slice(splitIndex);
                    
                    // Calculate visual widths to position them perfectly centered relative to original
                    const dims1 = getSetDimensions(tiles1.length);
                    const dims2 = getSetDimensions(tiles2.length);
                    const gap = 10; // 10px visual gap

                    const totalWidth = dims1.width + gap + dims2.width;
                    
                    // We want: Center of TotalWidth to be at set.x
                    // Left Set Center = set.x - (Total/2) + (Width1/2)
                    // Right Set Center = Left Set Right Edge + Gap + (Width2/2)
                    
                    const x1 = set.x - (totalWidth / 2) + (dims1.width / 2);
                    const x2 = x1 + (dims1.width / 2) + gap + (dims2.width / 2);

                    const newSet1 = {
                        ...set,
                        id: uuidv4(),
                        tiles: tiles1,
                        x: x1,
                        y: set.y 
                    };
                    
                    const newSet2 = {
                        ...set,
                        id: uuidv4(),
                        tiles: tiles2,
                        x: x2,
                        y: set.y
                    };

                    const newBoard = [...gameState.board];
                    newBoard.splice(setIndex, 1, newSet1, newSet2);
                    
                    setGameState(prev => ({
                        ...prev,
                        board: newBoard,
                    }));
                }
                return;
            }

            // --- EXISTING IMPLICIT ADD LOGIC ---
            const pidTop = 'TOP';
            const pidBottom = 'BOTTOM';
            
            const topSel = gameState.selectedTileIds[pidTop];
            const bottomSel = gameState.selectedTileIds[pidBottom];
            
            let actingPlayer = null;
            if (topSel.length > 0 && bottomSel.length === 0) actingPlayer = pidTop;
            else if (bottomSel.length > 0 && topSel.length === 0) actingPlayer = pidBottom;
            else if (topSel.length > 0 && bottomSel.length > 0) {
                actingPlayer = gameState.activePlayer || pidBottom;
            }

            if (!actingPlayer) return;

            const targetSetIndex = gameState.board.findIndex(b => b.id === setId);
            if (targetSetIndex === -1) return;

            const targetSet = gameState.board[targetSetIndex];
            const hand = getActiveHand(actingPlayer);
            const selection = gameState.selectedTileIds[actingPlayer];
            const selectedTiles = hand.filter(t => selection.includes(t.id));

            if (selectedTiles.length === 0) return;

            const isReordering = gameState.interactionMode === 'REORDER_BOARD';
            let newTiles = null;

            if (isReordering) {
                const combined = [...targetSet.tiles, ...selectedTiles];
                newTiles = autoSortSet(combined, false); // loose sort
            } else {
                newTiles = validateMove(targetSet.tiles, selectedTiles);
            }

            if (newTiles) {
                const newHand = hand.filter(t => !selection.includes(t.id));
                const newBoard = [...gameState.board];
                newBoard[targetSetIndex] = { ...targetSet, tiles: newTiles };

                setGameState(prev => ({
                    ...prev,
                    board: newBoard,
                    playerTopHand: actingPlayer === 'TOP' ? newHand : prev.playerTopHand,
                    playerBottomHand: actingPlayer === 'BOTTOM' ? newHand : prev.playerBottomHand,
                    selectedTileIds: {
                        ...prev.selectedTileIds,
                        [actingPlayer]: []
                    },
                    lastDrawnTileId: {
                      ...prev.lastDrawnTileId,
                      [actingPlayer]: null
                  }
                }));
            }
        };

        const toggleReorder = () => {
            setGameState(prev => {
                if (prev.interactionMode === 'REORDER_BOARD') {
                    if (!validateBoard(prev.board)) {
                        return prev; 
                    }
                    return { 
                        ...prev, 
                        interactionMode: 'IDLE', 
                        boardSnapshot: null, 
                        rackSnapshots: null,
                        activePlayer: null 
                    };
                } else {
                    return {
                      ...prev,
                      interactionMode: 'REORDER_BOARD',
                      boardSnapshot: JSON.parse(JSON.stringify(prev.board)),
                      rackSnapshots: {
                          TOP: JSON.parse(JSON.stringify(prev.playerTopHand)),
                          BOTTOM: JSON.parse(JSON.stringify(prev.playerBottomHand))
                      },
                      activePlayer: null 
                    };
                }
            });
        };
        
        const toggleSplitMode = () => {
            setGameState(prev => ({
                ...prev,
                interactionMode: prev.interactionMode === 'SPLIT_SET' ? 'IDLE' : 'SPLIT_SET'
            }));
        };

        const handleResetBoard = () => {
            setGameState(prev => ({
                ...prev,
                board: prev.boardSnapshot ? JSON.parse(JSON.stringify(prev.boardSnapshot)) : prev.board,
                playerTopHand: prev.rackSnapshots ? JSON.parse(JSON.stringify(prev.rackSnapshots.TOP)) : prev.playerTopHand,
                playerBottomHand: prev.rackSnapshots ? JSON.parse(JSON.stringify(prev.rackSnapshots.BOTTOM)) : prev.playerBottomHand,
            }));
        };

        // Convert active drags map to list for simple checking in props
        const draggingTileIds = Object.values(gameState.activeDrags).map(d => d.tileId).filter(id => id !== null);

        return (
          <div 
              className="flex flex-col h-screen w-screen overflow-hidden bg-gray-900 font-sans touch-none"
              onPointerMove={handlePointerMove}
              onPointerUp={handlePointerUp}
              onPointerCancel={handlePointerUp}
              onContextMenu={(e) => e.preventDefault()} 
          >
            
            {/* Top Player Rack */}
            {gameState.gamePhase === 'PLAYING' && (
              <PlayerRack 
                  playerId="TOP"
                  tiles={gameState.playerTopHand}
                  selectedTileIds={gameState.selectedTileIds.TOP}
                  draggedTileIds={draggingTileIds}
                  isMyTurn={gameState.activePlayer === 'TOP'}
                  onSort={(method) => handleSort('TOP', method)}
                  onDraw={() => handleDraw('TOP')}
                  onPlayNewSet={() => handlePlayNewSet('TOP')}
                  onDragStart={handleDragStart}
                  interactionMode={gameState.interactionMode}
                  disabled={false}
                  newTileId={gameState.lastDrawnTileId.TOP}
              />
            )}

            {/* Shared Board Area */}
            <GameBoard 
              sets={gameState.board}
              interactionMode={gameState.interactionMode}
              gamePhase={gameState.gamePhase}
              setupState={gameState.setupState}
              draggedTileIds={draggingTileIds}
              hasSelectedTiles={gameState.selectedTileIds.TOP.length > 0 || gameState.selectedTileIds.BOTTOM.length > 0}
              onSetClick={handleSetClick}
              onToggleReorder={toggleReorder}
              onResetBoard={handleResetBoard}
              onResetGame={handleResetGame}
              onDragStart={handleDragStart}
              onSetupDraw={handleSetupDraw}
              onStartGame={handleStartGame}
              onSetDragStart={handleSetDragStart}
              onSetRotate={handleSetRotate}
              onCycleRotate={handleCycleRotate}
              onCompactBoard={handleCompactBoard}
              onToggleSplit={toggleSplitMode}
            />

            {/* Bottom Player Rack */}
            {gameState.gamePhase === 'PLAYING' && (
              <PlayerRack 
                  playerId="BOTTOM"
                  tiles={gameState.playerBottomHand}
                  selectedTileIds={gameState.selectedTileIds.BOTTOM}
                  draggedTileIds={draggingTileIds}
                  isMyTurn={gameState.activePlayer === 'BOTTOM'}
                  onSort={(method) => handleSort('BOTTOM', method)}
                  onDraw={() => handleDraw('BOTTOM')}
                  onPlayNewSet={() => handlePlayNewSet('BOTTOM')}
                  onDragStart={handleDragStart}
                  interactionMode={gameState.interactionMode}
                  disabled={false}
                  newTileId={gameState.lastDrawnTileId.BOTTOM}
              />
            )}

            {/* Dragging Previews - Render one for each active touch */}
            {Object.entries(gameState.activeDrags).map(([pointerId, dragItem]) => {
                const drag = dragItem;
                if (!drag.isDragging || !drag.tileData) return null;
                const offset = dragOffsetsRef.current[parseInt(pointerId)] || { x: 0, y: 0 };
                
                return (
                    <div 
                      key={pointerId}
                      className="fixed pointer-events-none z-50 shadow-2xl opacity-90 scale-110"
                      style={{ 
                          left: drag.x - offset.x, 
                          top: drag.y - offset.y
                      }}
                    >
                        <Tile tile={drag.tileData} size="md" />
                    </div>
                );
            })}

            {/* CUSTOM CONFIRMATION MODAL */}
            {showNewGameModal && (
                <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-sm p-4">
                    <div className="bg-gray-800 border border-gray-600 p-8 rounded-2xl shadow-2xl max-w-sm w-full flex flex-col gap-6 animate-in fade-in zoom-in duration-200">
                        <div className="flex flex-col items-center gap-2">
                            <AlertTriangle size={48} className="text-yellow-500 mb-2" />
                            <h2 className="text-2xl font-bold text-white text-center">Start New Game?</h2>
                            <p className="text-gray-300 text-center text-lg leading-relaxed">
                                Are you sure? This will erase the current game and return to the setup phase.
                            </p>
                        </div>
                        <div className="flex gap-4">
                            <button 
                                onClick={() => setShowNewGameModal(false)}
                                className="flex-1 py-4 rounded-xl bg-gray-700 text-white font-bold text-lg active:scale-95 transition-transform hover:bg-gray-600"
                            >
                                Cancel
                            </button>
                            <button 
                                onClick={confirmNewGameReset}
                                className="flex-1 py-4 rounded-xl bg-red-600 text-white font-bold text-lg shadow-lg active:scale-95 transition-transform hover:bg-red-500"
                            >
                                New Game
                            </button>
                        </div>
                    </div>
                </div>
            )}

          </div>
        );
      };

      const rootElement = document.getElementById('root');
      if (!rootElement) {
        throw new Error("Could not find root element to mount to");
      }

      const root = createRoot(rootElement);
      root.render(
        <React.StrictMode>
          <App />
        </React.StrictMode>
      );
    </script>
  </body>
</html>
